<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Robertson problem · PositiveIntegrators.jl</title><meta name="title" content="Robertson problem · PositiveIntegrators.jl"/><meta property="og:title" content="Robertson problem · PositiveIntegrators.jl"/><meta property="twitter:title" content="Robertson problem · PositiveIntegrators.jl"/><meta name="description" content="Documentation for PositiveIntegrators.jl."/><meta property="og:description" content="Documentation for PositiveIntegrators.jl."/><meta property="twitter:description" content="Documentation for PositiveIntegrators.jl."/><meta property="og:url" content="https://SKopecz.github.io/PositiveIntegrators.jl/stable/robertson_benchmark/"/><meta property="twitter:url" content="https://SKopecz.github.io/PositiveIntegrators.jl/stable/robertson_benchmark/"/><link rel="canonical" href="https://SKopecz.github.io/PositiveIntegrators.jl/stable/robertson_benchmark/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PositiveIntegrators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../npzd_model/">NPZD model</a></li><li><a class="tocitem" href="../robertson/">Robertson problem</a></li><li><a class="tocitem" href="../stratospheric_reaction/">Stratospheric reaction problem</a></li><li><a class="tocitem" href="../linear_advection/">Linear Advection</a></li><li><a class="tocitem" href="../heat_equation_neumann/">Heat Equation, Neumann BCs</a></li><li><a class="tocitem" href="../heat_equation_dirichlet/">Heat Equation, Dirichlet BCs</a></li><li><a class="tocitem" href="../scalar_pds/">Scalar equation</a></li></ul></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../convergence/">Experimental order of convergence</a></li><li><a class="tocitem" href="../npzd_model_benchmark/">NPZD model</a></li><li class="is-active"><a class="tocitem" href>Robertson problem</a><ul class="internal"><li><a class="tocitem" href="#Work-Precision-diagrams"><span>Work-Precision diagrams</span></a></li><li><a class="tocitem" href="#Package-versions"><span>Package versions</span></a></li></ul></li><li><a class="tocitem" href="../stratospheric_reaction_benchmark/">Stratospheric reaction problem</a></li></ul></li><li><a class="tocitem" href="../faq/">Troubleshooting, FAQ</a></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of conduct</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Benchmarks</a></li><li class="is-active"><a href>Robertson problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Robertson problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SKopecz/PositiveIntegrators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SKopecz/PositiveIntegrators.jl/blob/main/docs/src/robertson_benchmark.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="benchmark-robertson"><a class="docs-heading-anchor" href="#benchmark-robertson">Benchmark: Solution of the Robertson problem</a><a id="benchmark-robertson-1"></a><a class="docs-heading-anchor-permalink" href="#benchmark-robertson" title="Permalink"></a></h1><p>Here we use the stiff Robertson problem <a href="../api_reference/#PositiveIntegrators.prob_pds_robertson"><code>prob_pds_robertson</code></a> to assess the efficiency of different solvers from <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a> and <a href="https://github.com/SKopecz/PositiveIntegrators.jl">PositiveIntegrators.jl</a>.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqFIRK, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqSDIRK
using PositiveIntegrators

# select Robertson problem
prob = prob_pds_robertson</code></pre><p>To keep the following code as clear as possible, we define a helper function <code>robertson_plot</code> that we use for plotting.</p><pre><code class="language-julia hljs">using Plots

function robertson_plot(sol, sol_ref = nothing, title = &quot;&quot;)
    colors = palette(:default)[1:3]&#39;
    if !isnothing(sol_ref)
        p = plot(sol_ref, tspan = (1e-6, 1e11), xaxis = :log,
                 idxs = [(0, 1), ((x, y) -&gt; (x, 1e4 .* y), 0, 2), (0, 3)],
                 linestyle = :dash, label = &quot;&quot;, color = colors, linewidth = 2)
        plot!(p, sol; tspan = (1e-6, 1e11), xaxis = :log, denseplot = false,
              markers = :circle, ylims = (-0.2, 1.2),
              idxs = [(0, 1), ((x, y) -&gt; (x, 1e4 .* y), 0, 2), (0, 3)],
              title, xticks = 10.0 .^ (-6:4:10), color = colors,
              linewidht = 2, legend = :right, label = [&quot;u₁&quot; &quot;10⁴ u₂&quot; &quot;u₃&quot;])
    else
        p = plot(sol; tspan = (1e-6, 1e11), xaxis = :log, denseplot = false,
                 markers = :circle, ylims = (-0.2, 1.2),
                 idxs = [(0, 1), ((x, y) -&gt; (x, 1e4 .* y), 0, 2), (0, 3)],
                 title, xticks = 10.0 .^ (-6:4:10), color = colors,
                 linewidht = 2, legend = :right, label = [&quot;u₁&quot; &quot;10⁴ u₂&quot; &quot;u₃&quot;])
    end
    return p
end</code></pre><p>For this stiff problem the computation of negative approximations may lead to inaccurate solutions.  This typically occurs when adaptive time stepping uses loose tolerances.</p><pre><code class="language-julia hljs"># compute reference solution for plotting
ref_sol = solve(prob, Rodas4P(); abstol = 1e-14, reltol = 1e-13);

# compute solutions with loose tolerances
abstol = 1e-2
reltol = 1e-1
sol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol);
sol_MPRK = solve(prob, MPRK22(1.0); abstol, reltol);

# plot solutions
p1 = robertson_plot(sol_Ros23, ref_sol, &quot;Rosenbrock23&quot;);
p2 = robertson_plot(sol_MPRK, ref_sol, &quot;MPRK22(1.0)&quot;);
plot(p1, p2)</code></pre><img src="2600771b.svg" alt="Example block output"/><p>Nevertheless, <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a> provides the solver option <code>isoutofdomain</code>, which can be used in combination with <a href="../api_reference/#PositiveIntegrators.isnegative"><code>isnegative</code></a> to guarantee nonnegative solutions. </p><pre><code class="language-julia hljs">sol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol,
                  isoutofdomain = isnegative) #reject negative solutions

robertson_plot(sol_Ros23, ref_sol, &quot;Rosenbrock23&quot;)</code></pre><img src="de6a122b.svg" alt="Example block output"/><h2 id="Work-Precision-diagrams"><a class="docs-heading-anchor" href="#Work-Precision-diagrams">Work-Precision diagrams</a><a id="Work-Precision-diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#Work-Precision-diagrams" title="Permalink"></a></h2><p>In the following we show several work-precision diagrams, which compare different methods with respect to computing time and the respective error.  We focus solely on adaptive methods, since the time interval <span>$(0, 10^{11})$</span> is too large to generate accurate solutions with fixed step sizes.</p><p>Since the Robertson problem is stiff, we need to use a suited implicit scheme to compute a reference solution, see the <a href="https://docs.sciml.ai/DiffEqDocs/dev/solvers/ode_solve/#Stiff-Problems">solver guide</a>. Note that we cannot use the recommended method <code>radau()</code>, since <a href="../api_reference/#PositiveIntegrators.prob_pds_robertson"><code>prob_pds_robertson</code></a> uses <a href="https://juliaarrays.github.io/StaticArrays.jl/stable/">StaticArrays.jl</a> instead of standard <code>Array</code>s.</p><pre><code class="language-julia hljs"># select solver to compute reference solution
alg_ref = Rodas4P()</code></pre><p>We use the functions <a href="../api_reference/#PositiveIntegrators.work_precision_adaptive"><code>work_precision_adaptive</code></a> and <a href="../api_reference/#PositiveIntegrators.work_precision_adaptive!"><code>work_precision_adaptive!</code></a> to compute the data for the diagrams. Furthermore, the following absolute and relative tolerances are used.</p><pre><code class="language-julia hljs"># set absolute and relative tolerances
abstols = 1.0 ./ 10.0 .^ (2:1:10)
reltols = abstols .* 10.0</code></pre><h3 id="Relative-maximum-error-at-the-final-time"><a class="docs-heading-anchor" href="#Relative-maximum-error-at-the-final-time">Relative maximum error at the final time</a><a id="Relative-maximum-error-at-the-final-time-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-maximum-error-at-the-final-time" title="Permalink"></a></h3><p>In this section the chosen error is the relative maximum error at the final time <span>$t = 10^{11}$</span>.</p><pre><code class="language-julia hljs"># select relative maximum error at the end of the problem&#39;s time span.
compute_error = rel_max_error_tend</code></pre><p>We start with a comparison of different adaptive MPRK schemes.</p><pre><code class="language-julia hljs"># choose methods to compare
algs = [MPRK22(0.5); MPRK22(2.0 / 3.0); MPRK22(1.0); MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75);
        MPRK43II(0.5); MPRK43II(2.0 / 3.0)]
labels = [&quot;MPRK22(0.5)&quot;; &quot;MPRK22(2/3)&quot;; &quot;MPRK22(1.0)&quot;; &quot;MPRK43I(1.0,0.5)&quot;; &quot;MPRK43I(0.5,0.75)&quot;;
         &quot;MPRK43II(0.5)&quot;; &quot;MPRK43II(2.0/3.0)&quot;]

# compute work-precision data
wp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;
                            adaptive_ref = true, compute_error)

# plot work-precision diagram
plot(wp, labels; title = &quot;Robertson benchmark&quot;, legend = :topright,
     color = permutedims([repeat([1], 3)..., repeat([3], 2)..., repeat([4], 2)...]),
     xlims = (10^-10, 10^0), xticks = 10.0 .^ (-10:1:0),
     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)</code></pre><img src="c19eef45.svg" alt="Example block output"/><p>We see that the second- and third-order schemes perform very similar, except for <code>MPRK22(0.5)</code>. This superior performance of <code>MPRK22(0.5)</code> cannot be seen in other benchmarks; it is, therefore, an exception here.</p><p>The scheme <code>SSPMPRK22(0.5, 1.0)</code> has not been considered above, since it generates oscillatory solutions.</p><pre><code class="language-julia hljs">sol1 = solve(prob, SSPMPRK22(0.5, 1.0), abstol=1e-5, reltol = 1e-4);

# plot solutions
robertson_plot(sol1, ref_sol, &quot;SSPMPRK22(0.5, 1.0)&quot;)</code></pre><img src="712e6ece.svg" alt="Example block output"/><p>For comparisons with schemes from <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a>, we choose the second-order schemes <code>MPRK22(0.5)</code> and <code>MPRK22(1.0)</code> as well as the third-order scheme <code>MPRK43I(0.5, 0.75)</code>.</p><pre><code class="language-julia hljs">sol_MPRK22_½ = solve(prob, MPRK22(0.5); abstol, reltol)
sol_MPRK22_1 = solve(prob, MPRK22(1.0); abstol, reltol)
sol_MPRK43 = solve(prob, MPRK43I(0.5, 0.75); abstol, reltol)

p1 = robertson_plot(sol_MPRK22_½, ref_sol, &quot;MPRK22(0.5)&quot;);
p2 = robertson_plot(sol_MPRK22_1, ref_sol, &quot;MPRK22(1.0)&quot;);
p3 = robertson_plot(sol_MPRK43, ref_sol, &quot;MPRK43I(0.5, 0.75)&quot;);
plot(p1, p2, p3)</code></pre><img src="f7c24330.svg" alt="Example block output"/><p>Now we compare these three schemes with a selection of second- and third-order stiff solvers from <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a>. To guarantee nonnegative solutions, we use the solver option <code>isoutofdomain = isnegative</code>.</p><pre><code class="language-julia hljs"># select reference MPRK methods
algs1 = [MPRK22(0.5); MPRK22(1.0); MPRK43I(0.5, 0.75)]
labels1 = [&quot;MPRK22(0.5)&quot;; &quot;MPRK22(1.0)&quot;; &quot;MPRK43I(0.5,0.75)&quot;]

# select methods from OrdinaryDiffEq
algs2 = [TRBDF2(); Kvaerno3(); KenCarp3(); Rodas3(); ROS2(); ROS3(); Rosenbrock23()]
labels2 = [&quot;TRBDF2&quot;; &quot;Kvearno3&quot;; &quot;KenCarp3&quot;; &quot;Rodas3&quot;; &quot;ROS2&quot;; &quot;ROS3&quot;; &quot;Rosenbrock23&quot;]

# compute work-precision data
wp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error)
# add work-precision data with isoutofdomain = isnegative
work_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)

# plot work-precision diagram
plot(wp, [labels1; labels2]; title = &quot;Robertson benchmark&quot;, legend = :topright,
     color = permutedims([repeat([1], 2)..., 3, repeat([5], 3)..., repeat([6], 4)...]),
     xlims = (10^-10, 10^3), xticks = 10.0 .^ (-14:1:3),
     ylims = (10^-6, 10^1), yticks = 10.0 .^ (-6:1:0), minorticks = 10)</code></pre><img src="9330f52d.svg" alt="Example block output"/><p>We see that <code>MPRK22(1.0)</code> and <code>MPRK43I(0.5, 0.75)</code> perform similar to <code>Ros3()</code> or <code>Rosenbrock23()</code> and are a good choice as long as low accuracy is acceptable. For high accuracy we should employ a scheme like <code>KenCarp3()</code>. As for <code>MPRK22(0.5)</code> the  superior performance of <code>Rodas3()</code> seems to be an exception here.</p><p>In addition,  we compare <code>MPRK22(1.0)</code> and <code>MPRK43I(0.5, 0.75)</code> to some <a href="https://docs.sciml.ai/DiffEqDocs/dev/solvers/ode_solve/">recommended solvers</a> of higher order from <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a>. Again, to guarantee positive solutions we select the solver option <code>isoutofdomain = isnegative</code>.</p><pre><code class="language-julia hljs">algs3 = [Rodas5P(); Rodas4P(); RadauIIA5()]
labels3 = [&quot;Rodas5P&quot;; &quot;Rodas4P&quot;; &quot;RadauIIA5&quot;]

# compute work-precision data
wp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error)
# add work-precision data with isoutofdomain = isnegative
work_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)

# plot work-precision diagram
plot(wp, [labels1; labels3]; title = &quot;Robertson benchmark&quot;, legend = :topright,
     color = permutedims([repeat([1],2)..., 3, repeat([4], 2)..., 5]),
     xlims = (10^-10, 2*10^0), xticks = 10.0 .^ (-10:1:0),
     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)</code></pre><img src="03e37f96.svg" alt="Example block output"/><p>Again, we see that the MPRK schemes are in general only beneficial if low accuracy is acceptable.</p><h3 id="Relative-maximum-error-over-all-time-steps"><a class="docs-heading-anchor" href="#Relative-maximum-error-over-all-time-steps">Relative maximum error over all time steps</a><a id="Relative-maximum-error-over-all-time-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-maximum-error-over-all-time-steps" title="Permalink"></a></h3><p>In this section we do not compare the relative maximum errors at the final time <span>$t = 10^{11}$</span>, but the relative maximum errors over all time steps. </p><pre><code class="language-julia hljs"># select relative maximum error at the end of the problem&#39;s time span.
compute_error = rel_max_error_overall</code></pre><p>First, we compare different MPRK schemes. As above, we omit <code>SSPMPRK22(0.5, 1.0)</code>.</p><pre><code class="language-julia hljs"># compute work-precision data
wp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;
                            adaptive_ref = true, compute_error)

# plot work-precision diagram
plot(wp, labels; title = &quot;Robertson benchmark&quot;, legend = :top,
     color = permutedims([repeat([1], 3)..., repeat([3], 2)..., repeat([4], 2)...]),
     xlims = (10^-4, 5*10^1), xticks = 10.0 .^ (-5:1:2),
     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)</code></pre><img src="6f7706a2.svg" alt="Example block output"/><p>Notably, the error of the second-order methods does not decrease when stricter tolerances are used. We choose the second-order scheme <code>MPRK22(1.0)</code> and the third-order scheme <code>MPRK43I(0.5, 0.75)</code> for comparison with solvers from <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a>. To guarantee nonnegative solutions of these methods, we select the solver option <code>isoutofdomain = isnegative</code>.</p><pre><code class="language-julia hljs"># select reference MPRK methods
algs1 = [MPRK22(1.0); MPRK43I(0.5, 0.75)]
labels1 = [&quot;MPRK22(1.0)&quot;; &quot;MPRK43I(0.5,0.75)&quot;]

# compute work-precision data
wp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error)
# add work-precision data with isoutofdomain = isnegative
work_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)

# plot work-precision diagram
plot(wp, [labels1; labels2]; title = &quot;Robertson benchmark&quot;, legend = :bottomleft,
     color = permutedims([1, 3, repeat([5], 3)..., repeat([6], 4)...]),
     xlims = (10^-5, 10^2), xticks = 10.0 .^ (-14:1:3),
     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)</code></pre><img src="3f4b2c33.svg" alt="Example block output"/><p>Here too, some methods show that the error does not decrease even though stricter tolerances are used.</p><p>Finally, we compare <code>MPRK43I(0.5, 0.75)</code> and <code>MPRK22(1.0)</code> to <a href="https://docs.sciml.ai/DiffEqDocs/dev/solvers/ode_solve/">recommended solvers</a> of higher order from <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a>. Again, to guarantee positive solutions we select the solver option <code>isoutofdomain = isnegative</code>.</p><pre><code class="language-julia hljs"># compute work-precision data
wp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error)
# add work-precision data with isoutofdomain = isnegative
work_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;
                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)

# plot work-precision diagram
plot(wp, [labels1; labels3]; title = &quot;Robertson benchmark&quot;, legend = :topright,
     color = permutedims([1, 3, repeat([4], 2)..., 5]),
     xlims = (10^-4, 2*10^0), xticks = 10.0 .^ (-11:1:0),
     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)</code></pre><img src="f94c06ab.svg" alt="Example block output"/><h2 id="Package-versions"><a class="docs-heading-anchor" href="#Package-versions">Package versions</a><a id="Package-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Package-versions" title="Permalink"></a></h2><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()
println()

using Pkg
Pkg.status([&quot;PositiveIntegrators&quot;, &quot;StaticArrays&quot;, &quot;LinearSolve&quot;,
            &quot;OrdinaryDiffEqFIRK&quot;, &quot;OrdinaryDiffEqRosenbrock&quot;,
            &quot;OrdinaryDiffEqSDIRK&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.11.4
Commit 8561cc3d68d (2025-03-10 11:36 UTC)
Build Info:
  Official https://julialang.org/ release
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 4 × AMD EPYC 7763 64-Core Processor
  WORD_SIZE: 64
  LLVM: libLLVM-16.0.6 (ORCJIT, znver3)
Threads: 1 default, 0 interactive, 1 GC (on 4 virtual cores)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager

<span class="sgr32"><span class="sgr1">Status</span></span> `~/work/PositiveIntegrators.jl/PositiveIntegrators.jl/docs/Manifest.toml`
<span class="sgr33">⌅</span> <span class="sgr90">[7ed4a6bd] </span>LinearSolve v2.39.0
  <span class="sgr90">[5960d6e9] </span>OrdinaryDiffEqFIRK v1.9.0
  <span class="sgr90">[43230ef6] </span>OrdinaryDiffEqRosenbrock v1.8.0
  <span class="sgr90">[2d112036] </span>OrdinaryDiffEqSDIRK v1.3.0
  <span class="sgr90">[d1b20bf0] </span>PositiveIntegrators v0.2.9-DEV `~/work/PositiveIntegrators.jl/PositiveIntegrators.jl`
  <span class="sgr90">[90137ffa] </span>StaticArrays v1.9.13
<span class="sgr36"><span class="sgr1">Info</span></span> Packages marked with <span class="sgr33">⌅</span> have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../npzd_model_benchmark/">« NPZD model</a><a class="docs-footer-nextpage" href="../stratospheric_reaction_benchmark/">Stratospheric reaction problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Monday 24 March 2025 03:39">Monday 24 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
