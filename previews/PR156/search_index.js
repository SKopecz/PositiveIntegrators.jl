var documenterSearchIndex = {"docs":
[{"location":"stratospheric_reaction_benchmark/#benchmark-stratos","page":"Stratospheric reaction problem","title":"Benchmark: Solution of a stratospheric reaction problem","text":"","category":"section"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"We use the stiff stratospheric reaction problem prob_pds_stratreac to assess the efficiency of different solvers from OrdinaryDiffEq.jl and PositiveIntegrators.jl.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using OrdinaryDiffEqFIRK, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqSDIRK\nusing PositiveIntegrators\n# select problem\nprob = prob_pds_stratreac\nnothing # hide","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"To keep the following code as clear as possible, we define a helper function stratreac_plot that we use for plotting.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using Plots\n\nfunction stratreac_plot(sols, labels = fill(\"\", length(sols)), sol_ref = nothing)\n    if !(sols isa Vector)\n        sols = [sols]\n    end\n    if !(labels isa Vector)\n        labels = [labels]\n    end\n\n    tspan = prob_pds_stratreac.tspan\n    layout = (3, 2)\n    linewidth = 2\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4))\n    tickfontsize = 7\n    xguide = \"t [h]\" #fill(\"t [h]\", 1, 6)\n    xguidefontsize = 8\n    yguide = [\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"]\n    ylims = [(-20, 120) (-1e8, 7e8) (2e11, 6e11) (1.69699e16, 1.69705e16) (-2e6, 1.2e7) (1.084e9,\n                                                                                         1.098e9)]\n    legend = :outertop\n    legend_column = -1\n    widen = true\n\n    if !isnothing(sol_ref)\n        p = plot(ref_sol; layout, linestyle = :dash, label = \"Ref.\", linewidth)\n        for (sol, label) in zip(sols, labels)\n            plot!(p, sol; xguide, xguidefontsize, xticks, tickfontsize, yguide, legend,\n                  legend_column, widen, ylims, linewidth, label, denseplot = false)\n        end\n    else\n        p = plot(sols[1]; layout, xguide, xguidefontsize, xticks, tickfontsize, yguide,\n                 legend, legend_column, widen, ylims, linewidth,\n                 label = labels[1])\n        if length(sols) > 1\n            for (sol, label) in zip(sols[2:end], labels[2:end])\n                plot!(p, sol; layout, xguide, xguidefontsize, xticks, tickfontsize, yguide,\n                      legend, legend_column, widen, label, denseplot = false, linewidth,\n                      ylims)\n            end\n        end\n    end\n    return p\nend\nnothing # hide","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"First, we show approximations of Rosenbrock23() using loose tolerances.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# compute reference solution for plotting\nref_sol = solve(prob, Rodas4P(); abstol = 1e-12, reltol = 1e-11);\n\n# compute solution with low tolerances\nabstol = 1e-3\nreltol = 1e-2\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol);\n\n# plot solution\nstratreac_plot(sol_Ros23,  \"Ros23\", ref_sol)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Although not visible in the plots, the Rosenbrock23 solution contains negative values.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"isnonnegative(sol_Ros23)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Nevertheless, OrdinaryDiffEq.jl provides the solver option isoutofdomain, which can be used in combination with isnegative to guarantee nonnegative solutions.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# compute solution with isoutofdomain = isnegative\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol,\n                  isoutofdomain = isnegative); #reject negative solutions\n\n# plot solution\nstratreac_plot(sol_Ros23,  \"Ros23\", ref_sol)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"For this problem, using adaptive MPRK schemes with loose tolerances will generally lead to poor approximations, particularly regarding the O₂ component.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"sol_MPRK = solve(prob, MPRK22(1.0); abstol, reltol);\n\n# plot solutions\nstratreac_plot(sol_MPRK, \"MPRK22(1.0)\", ref_sol)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"To improve the solution of the MPRK scheme we can inrecase the method's small_constant. Trial and error has shown that small_constant = 1e-6 is a good value for this problem and the given tolerances.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# compute MPRK solution with modified small_constant\nsol_MPRK = solve(prob, MPRK22(1.0, small_constant = 1e-6); abstol, reltol);\n\n# plot solution\nstratreac_plot(sol_MPRK, \"MPRK22(1.0)\", ref_sol)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The remaining poor approximation of the O₂ component could be due to the fact that the MPRK methods do not preserve all linear invariants, as is the case with standard methods like Runge-Kutta or Rosenbrock schemes.","category":"page"},{"location":"stratospheric_reaction_benchmark/#Work-Precision-diagrams","page":"Stratospheric reaction problem","title":"Work-Precision diagrams","text":"","category":"section"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In the following we show several work-precision diagrams, which compare different methods with respect to computing times and errors. First we focus on adaptive methods, afterwards we also show results obtained with fixed time step sizes.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Since the stratospheric reaction problem is stiff, we need to use a suited implicit scheme to compute its reference solution.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# select solver to compute reference solution\nalg_ref = Rodas4P()\nnothing  # hide","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The error chosen to compare the performances of different solvers is the relative maximum error at the final time t = 84 hours (t = 302400 seconds).","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing # hide","category":"page"},{"location":"stratospheric_reaction_benchmark/#Adaptive-time-stepping","page":"Stratospheric reaction problem","title":"Adaptive time stepping","text":"","category":"section"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"We use the functions work_precision_adaptive and work_precision_adaptive! to compute the data for the diagrams. Furthermore, the following absolute and relative tolerances are used.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"abstols = 1.0 ./ 10.0 .^ (2:1:5)\nreltols = 10.0 .* abstols\nnothing # hide","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"We also note that MPRK schemes with stricter tolerances, quickly require more than a million time steps, which makes these schemes inefficient in such situations.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"First we compare different MPRK schemes. In addition to the default version we also use the schemes with small_constant = 1e-6.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# choose methods to compare\nalgs = [MPRK22(1.0); MPRK22(1.0, small_constant = 1e-6); SSPMPRK22(0.5, 1.0); SSPMPRK22(0.5, 1.0, small_constant = 1e-6);\n        MPRK43I(1.0, 0.5); MPRK43I(1.0, 0.5, small_constant = 1e-6); MPRK43I(0.5, 0.75); MPRK43I(0.5, 0.75, small_constant = 1e-6)\n        MPRK43II(0.5); MPRK43II(0.5, small_constant = 1e-6); MPRK43II(2.0 / 3.0); MPRK43II(2.0 / 3.0, small_constant = 1e-6)]\nlabels = [\"MPRK22(1.0)\"; \"MPRK22(1.0, sc=1e-6)\"; \"SSPMPRK22(0.5,1.0)\"; \"SSPMPRK22(0.5,1.0, sc=1e-6)\";\n          \"MPRK43I(1.0,0.5)\"; \"MPRK43I(1.0,0.5, sc=1e-6)\"; \"MPRK43I(0.5,0.75)\"; \"MPRK43I(0.5,0.75, sc=1e-6)\"; \"MPRK43II(0.5)\"; \"MPRK43II(0.5, sc=1e-6)\"\n          \"MPRK43II(2.0/3.0)\"; \"MPRK43II(2.0/3.0, sc=1e-6)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Stratospheric reaction benchmark\", legend = :bottomleft,\n     color = permutedims([repeat([1],2)..., repeat([2],2)..., repeat([3],4)..., repeat([4],4)...]),\n     xlims = (10^-7, 10^0), xticks = 10.0 .^ (-8:1:0),\n     ylims = (10^-5, 10^1), yticks = 10.0 .^ (-5:1:1), minorticks = 10)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"We see that using small_constant = 1e-6 clearly improves the performance of most methods. For comparisons with other second- and third-order schemes from OrdinaryDiffEq.jl we choose the second-order scheme MPRK22(1.0, small_constant = 1e-6) and the third-order scheme MPRK43I(0.5, 0.75). To guarantee positive solutions of the OrdinaryDiffEq.jl methods, we select the solver option isoutofdomain = isnegative.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# select reference MPRK methods\nalgs1 = [MPRK22(1.0, small_constant = 1e-6); MPRK43I(0.5, 0.75)]\nlabels1 = [\"MPRK22(1.0, sc=1e-6)\"; \"MPRK43I(0.5,0.75)\"]\n\n# select OrdinaryDiffEq methods\nalgs2 = [TRBDF2(); Kvaerno3(); KenCarp3(); Rodas3(); ROS2(); ROS3(); Rosenbrock23()]\nlabels2 = [\"TRBDF2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\"; \"ROS2\"; \"ROS3\"; \"Rosenbrock23\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref; compute_error)\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref; compute_error,\n                        isoutofdomain = isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"Stratospheric reaction benchmark\", legend = :bottomleft,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)...]),\n     xlims = (10^-8, 10^0), xticks = 10.0 .^ (-8:1:0),\n     ylims = (2*10^-4, 5*10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"We see that MPRK methods are advantageous if low accuracy is acceptable.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In addition,  we compare MPRK22(1.0, small_constant = 1e-6) and  MPRK43I(0.5, 0.75) to some recommended solvers of higher order from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# select OrdinaryDiffEq methods\nalgs3 = [Rodas5P(); Rodas4P(); RadauIIA5()]\nlabels3 = [\"Rodas5P\"; \"Rodas4P\"; \"RadauIIA5\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref; compute_error)\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref; compute_error,\n                        isoutofdomain = isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"Stratospheric reaction benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)...]),\n     xlims = (10^-7, 10^0), xticks = 10.0 .^ (-8:1:0),\n     ylims = (2*10^-4, 5*10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Again, it can be seen that MPRK methods are only advantageous if low accuracy is acceptable.","category":"page"},{"location":"stratospheric_reaction_benchmark/#Fixed-time-steps-sizes","page":"Stratospheric reaction problem","title":"Fixed time steps sizes","text":"","category":"section"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Here we use fixed time step sizes instead of adaptive time stepping. We use the functions work_precision_fixed and work_precision_fixed! to compute the data for the diagrams. Please note that these functions set error and computing time to Inf, whenever a solution contains negative elements. Consequently, such cases are not visible in the work-precision diagrams.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Within the work-precision diagrams we use the following time step sizes.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# set time step sizes\ndt0 = 48 * 60 # 48 minutes\ndts = dt0 ./ 2.0 .^ (0:1:10)\nnothing # hide","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In contrast to the adaptive methods, increasing small_constant does not have a positive effect on accuracy, but actually worsens it. To demonstrate this we compare the default version of MPRK22(1.0) to versions with small_constant = 1e-6 and small_constant = 1e-100.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# solve prob with large step size\nsol1 = solve(prob, MPRK22(1.0); dt = dt0, adaptive = false)\n# plot solution\nstratreac_plot(sol1, \"MPRK22(1.0)\", ref_sol)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"sol2 = solve(prob, MPRK22(1.0, small_constant = 1e-6); dt = dt0, adaptive = false)\nstratreac_plot(sol2, \"MPRK22(1.0, sc=1e-6)\", ref_sol)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"sol3 = solve(prob, MPRK22(1.0, small_constant = 1e-100); dt = dt0, adaptive = false)\nstratreac_plot(sol3, \"MPRK22(1.0, sc=1e-100)\", ref_sol)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Based on the above comparison, we will only consider schemes in which small_constant is set to the default value in the following.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# select schemes\nalgs = [MPRK22(1.0); SSPMPRK22(0.5, 1.0); MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75); MPRK43II(0.5); MPRK43II(2.0 / 3.0);\n        SSPMPRK43()]\nlabels = [\"MPRK22(1.0)\"; \"SSPMPRK22(0.5,1.0)\"; \"MPRK43I(1.0,0.5)\"; \"MPRK43I(0.5,0.75)\";  \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\";\n          \"SSPMPRK43()\"]\n\n# compute work-precision data\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Stratospheric reaction benchmark\", legend = :bottomleft,\n     color = permutedims([1, 2, repeat([3],2)..., repeat([4],2)..., 5]),\n     xlims = (10^-6, 10^2), xticks = 10.0 .^ (-8:1:2),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:1), minorticks = 10)","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Apart from SSPMPRK22(0.5, 1.0) all schemes perform quite similar. We choose MPRK22(1.0) and MPRK43II(0.5) for comparisons with other schemes.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"For the chosen time step sizes none of the above used standard schemes provides nonnegative solutions.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"# select reference MPRK methods\nalgs = [MPRK22(1.0); MPRK43II(0.5); TRBDF2(); Kvaerno3(); KenCarp3(); Rodas3(); ROS2(); ROS3(); Rosenbrock23();\n         Rodas5P(); Rodas4P()]\nlabels = [\"MPRK22(1.0)\"; \"MPRK43II(0.5)\"; \"TRBDF2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\"; \"ROS2\"; \"ROS3\"; \"Rosenbrock23\";\n          \"Rodas5P\"; \"Rodas4P\"]\n\n# compute work-precision data\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Stratospheric reaction benchmark\", legend = :bottomleft,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 3)...]),\n     xlims = (10^-6, 10^1), xticks = 10.0 .^ (-12:2:4),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"stratospheric_reaction_benchmark/#Package-versions","page":"Stratospheric reaction problem","title":"Package versions","text":"","category":"section"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"These results were obtained using the following versions.","category":"page"},{"location":"stratospheric_reaction_benchmark/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\",\n            \"OrdinaryDiffEqFIRK\", \"OrdinaryDiffEqRosenbrock\",\n            \"OrdinaryDiffEqSDIRK\"],\n           mode = PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/NumericalMathematics/PositiveIntegrators.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ContributingPositiveIntegrators.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.PositiveIntegrators.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"npzd_model/#tutorial-npzd","page":"NPZD model","title":"Tutorial: Solution of an NPZD model","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"This tutorial is about the efficient solution of production-destruction systems (PDS) with a small number of differential equations. We will compare the use of standard arrays and static arrays from StaticArrays.jl and assess their efficiency.","category":"page"},{"location":"npzd_model/#Definition-of-the-production-destruction-system","page":"NPZD model","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The NPZD model we want to solve was described by Burchard, Deleersnijder and Meister in Application of modified Patankar schemes to stiff biogeochemical models for the water column. The model reads","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"beginaligned\nN = 001P + 001Z + 0003D - fracNP001 + N\nP = fracNP001 + N- 001P - 05( 1 - e^-121P^2)Z - 005P\nZ = 05(1 - e^-121P^2)Z - 001Z - 002Z\nD = 005P + 002Z - 0003D\nendaligned","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"and we consider the initial conditions N=8, P=2, Z=1 and D=4. The time domain of interest is tin010.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The model can be represented as a conservative PDS with production terms","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"beginaligned\np_12 = 001 P  p_13 = 001 Z  p_14 = 0003 D\np_21 = fracNP001 + N  p_32 = 05  (10 - e^-121  P^2)  Z p_42 = 005  P\np_43 = 002  Z\nendaligned","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"whereby production terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix (p_ij)_ij=1^4.","category":"page"},{"location":"npzd_model/#Solution-of-the-production-destruction-system","page":"NPZD model","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"As mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"an out-of-place implementation with standard (dynamic) matrices and vectors,\nan in-place implementation with standard (dynamic) matrices and vectors,\nan out-of-place implementation with static matrices and vectors from StaticArrays.jl.","category":"page"},{"location":"npzd_model/#Standard-out-of-place-implementation","page":"NPZD model","title":"Standard out-of-place implementation","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Here we create a function to compute the production matrix with return type Matrix{Float64}.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction prod(u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    return [0.0 p12 p13 p14;\n            p21 0.0 0.0 0.0;\n            0.0 p32 0.0 0.0;\n            0.0 p42 p43 0.0]\nend\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The solution of the NPZD model can now be computed as follows.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"u0 = [8.0, 2.0, 1.0, 4.0] # initial values\ntspan = (0.0, 10.0) # time domain\nprob_oop = ConservativePDSProblem(prod, u0, tspan) # create the PDS\n\nsol_oop = solve(prob_oop, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Plotting the solution shows that the components N and P are in danger of becoming negative.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using Plots\n\nplot(sol_oop; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"PositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"isnonnegative(sol_oop)","category":"page"},{"location":"npzd_model/#Standard-in-place-implementation","page":"NPZD model","title":"Standard in-place implementation","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Next we create an in-place function for the production matrix.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"\nfunction prod!(PMat, u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    fill!(PMat, zero(eltype(PMat)))\n\n    PMat[1, 2] = p12\n    PMat[1, 3] = p13\n    PMat[1, 4] = p14\n    PMat[2, 1] = p21\n    PMat[3, 2] = p32\n    PMat[4, 2] = p42\n    PMat[4, 3] = p43\n\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The solution of the in-place implementation of the NPZD model can now be computed as follows.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"\nprob_ip = ConservativePDSProblem(prod!, u0, tspan)\nsol_ip = solve(prob_ip, MPRK43I(1.0, 0.5))\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"\nplot(sol_ip; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"We also check that the in-place and out-of-place solutions are equivalent.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"sol_oop.t ≈ sol_ip.t && sol_oop.u ≈ sol_ip.u","category":"page"},{"location":"npzd_model/#Using-static-arrays","page":"NPZD model","title":"Using static arrays","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"For PDS with a small number of differential equations like the NPZD model the use of static arrays will be more efficient. To create a function which computes the production matrix and returns a static matrix, we only need to add the @SMatrix macro.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using StaticArrays\n\nfunction prod_static(u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    return @SMatrix [0.0 p12 p13 p14;\n                     p21 0.0 0.0 0.0;\n                     0.0 p32 0.0 0.0;\n                     0.0 p42 p43 0.0]\nend\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"In addition we also want to use a static vector to hold the initial conditions.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"u0_static = @SVector [8.0, 2.0, 1.0, 4.0] # initial values\nprob_static = ConservativePDSProblem(prod_static, u0_static, tspan) # create the PDS\n\nsol_static = solve(prob_static, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using Plots\n\nplot(sol_static; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"This solution is also nonnegative.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"isnonnegative(sol_static)","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The above implementation of the NPZD model using StaticArrays can also be found in the Example Problems as prob_pds_npzd.","category":"page"},{"location":"npzd_model/#Performance-comparison","page":"NPZD model","title":"Performance comparison","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Finally, we use BenchmarkTools.jl to show the benefit of using static arrays.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using BenchmarkTools\n@benchmark solve(prob_oop, MPRK43I(1.0, 0.5))","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using BenchmarkTools\n@benchmark solve(prob_ip, MPRK43I(1.0, 0.5))","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"@benchmark solve(prob_static, MPRK43I(1.0, 0.5))","category":"page"},{"location":"npzd_model/#Package-versions","page":"NPZD model","title":"Package versions","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"These results were obtained using the following versions.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"npzd_model_benchmark/#benchmark-npzd","page":"NPZD model","title":"Benchmark: Solution of an NPZD model","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"We use the NPZD model prob_pds_npzd to assess the efficiency of different solvers from OrdinaryDiffEq.jl and PositiveIntegrators.jl.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"using OrdinaryDiffEqLowOrderRK, OrdinaryDiffEqSDIRK, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqTsit5, OrdinaryDiffEqVerner\nusing PositiveIntegrators\n\n# select NPZD problem\nprob = prob_pds_npzd\nnothing # hide","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"To keep the following code as clear as possible, we define a helper function npzd_plot that we use for plotting.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"using Plots\n\nfunction npzd_plot(sol, sol_ref = nothing, title = \"\")\n     colors = palette(:default)[1:4]'\n     if !isnothing(sol_ref)\n          p = plot(sol_ref, linestyle = :dash, label = \"\", color = colors,\n                   linewidth = 2)\n          plot!(p, sol; denseplot = false, markers = :circle, ylims = (-1.0, 10.0),\n                color = colors, title, label = [\"N\" \"P\" \"Z\" \"D\"], legend = :right,\n                linewidth = 2);\n     else\n          p = plot(sol; denseplot = false, markers = :circle, ylims = (-1.0, 10.0),\n                   color = colors, title, label = [\"N\" \"P\" \"Z\" \"D\"], legend = :right,\n                   linewidths = 2);\n     end\n     return p\nend\nnothing  # hide","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Standard methods have difficulties to solve the NPZD problem accurately for loose tolerances or large time step sizes. This is because the first variable, N, has only a tiny margin for negative values. In most cases, negative values of Nwill directly decrease Nfurther, resulting in completely inaccurate solutions.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# compute reference solution for plotting\nref_sol = solve(prob, Vern7(); abstol = 1e-14, reltol = 1e-13);\n\n# compute solutions with loose tolerances\nabstol = 1e-2\nreltol = 1e-1\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol);\nsol_MPRK = solve(prob, MPRK22(1.0); abstol, reltol);\n\n# plot solutions\np1 = npzd_plot(sol_Ros23, ref_sol, \"Rosenbrock23\"); # helper function defined above\np2 = npzd_plot(sol_MPRK, ref_sol, \"MPRK22(1.0)\");\nplot(p1, p2)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Nevertheless, OrdinaryDiffEq.jl provides the solver option isoutofdomain, which can be used in combination with isnegative to guarantee nonnegative solutions.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"sol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol,\n                  isoutofdomain = isnegative); #reject negative solutions\n\nnpzd_plot(sol_Ros23, ref_sol) #auxiliary function defined above","category":"page"},{"location":"npzd_model_benchmark/#Work-Precision-diagrams","page":"NPZD model","title":"Work-Precision diagrams","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"In the following sections, we present several work-precision diagrams that compare various methods in terms of computing time and error. First, we focus on adaptive methods; afterward, we also display resultsixed time step sizes. obtained with f","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Since the NPZD problem is not stiff, we can use an explicit high-order scheme to compute a reference solution.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# select solver to compute reference solution\nalg_ref = Vern7()\nnothing  # hide","category":"page"},{"location":"npzd_model_benchmark/#Adaptive-schemes","page":"NPZD model","title":"Adaptive schemes","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"We use the functions work_precision_adaptive and work_precision_adaptive! to compute the data for the diagrams. Furthermore, the following absolute and relative tolerances are used.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# set absolute and relative tolerances\nabstols = 1.0 ./ 10.0 .^ (2:1:8)\nreltols = abstols .* 10.0\nnothing  # hide","category":"page"},{"location":"npzd_model_benchmark/#Relative-maximum-error-at-the-final-time","page":"NPZD model","title":"Relative maximum error at the final time","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"In this section the chosen error is the relative maximum error at the final time t = 100.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing # hide","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"We start with a comparison of different adaptive MPRK schemes.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# choose methods to compare\nalgs = [MPRK22(0.5); MPRK22(2.0 / 3.0); MPRK22(1.0); SSPMPRK22(0.5, 1.0);\n        MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75); MPRK43II(0.5); MPRK43II(2.0 / 3.0)]\nlabels = [\"MPRK22(0.5)\"; \"MPPRK22(2/3)\"; \"MPRK22(1.0)\"; \"SSPMPRK22(0.5,1.0)\";\n          \"MPRK43I(1.0, 0.5)\"; \"MPRK43I(0.5, 0.75)\"; \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                               compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)...]),\n     xlims = (10^-7, 2*10^-1), xticks = 10.0 .^ (-8:1:0),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"The second- and third-order methods behave very similarly. For comparisons with other schemes from OrdinaryDiffEq.jl we choose MPRK22(1.0) and MPRK43I(1.0, 0.5).","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"sol_MPRK22 = solve(prob, MPRK22(1.0); abstol, reltol)\nsol_MPRK43 = solve(prob, MPRK43I(1.0, 0.5); abstol, reltol)\n\np1 = npzd_plot(sol_MPRK22, ref_sol, \"MPRK22(1.0)\");\np2 = npzd_plot(sol_MPRK43, ref_sol, \"MPRK43I(1.0, 0.5)\");\nplot(p1, p2)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Next we compare MPRK22(1.0) and MPRK43I(1.0, 0.5) to explicit and implicit methods of second and third order from OrdinaryDiffEq.jl. To guarantee nonnegative solutions, we select the solver option isoutofdomain = isnegative.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# select MPRK methods for reference\nalgs1 = [MPRK22(1.0); MPRK43I(1.0, 0.5)]\nlabels1 = [\"MPRK22(1.0)\"; \"MPRK43I(1.0,0.5)\"]\n\n# select methods from OrdinaryDiffEq\nalgs2 = [Midpoint(); Heun(); Ralston(); TRBDF2(); SDIRK2(); Kvaerno3(); KenCarp3(); Rodas3();\n         ROS2(); ROS3(); Rosenbrock23()]\nlabels2 = [\"Midpoint\"; \"Heun\"; \"Ralston\"; \"TRBDF2\"; \"SDIRK2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\";\n          \"ROS2\"; \"ROS3\"; \"Rosenbrock23\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain=isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain=isnegative)\n\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 4)...]),\n     xlims = (5*10^-8, 2*10^-1), xticks = 10.0 .^ (-8:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"We see that for the NPZD problem the use of adaptive MPRK schemes is only beneficial when using the loosest tolerances.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Now we compare MPRK22(1.0) and MPRK43I(1.0, 0.5) to recommended solvers from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"algs3 = [Tsit5(); BS3(); Vern6(); Vern7(); Vern8(); TRBDF2(); Rosenbrock23();\n         Rodas5P(); Rodas4P()]\nlabels3 = [\"Tsit5\"; \"BS3\"; \"Vern6\"; \"Vern7\"; \"Vern8\"; \"TRBDF2\"; \"Rosenbrock23\";\n          \"Rodas5P\"; \"Rodas4P\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain = isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 5)...,5, repeat([6], 1)...,repeat([7],2)...]),\n     xlims = (10^-11, 10^1), xticks = 10.0 .^ (-11:1:1),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"We see that it is advisable to use a high-order explicit method like Vern7() or Rosenbrock methods like Rodas4P() with isoutofdomain = isnegative to obtain nonnegative solutions of such a non-stiff problem.","category":"page"},{"location":"npzd_model_benchmark/#Relative-maximum-error-over-all-time-steps","page":"NPZD model","title":"Relative maximum error over all time steps","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"In this section we do not compare the relative maximum errors at the final time t = 100, but the relative maximum errors over all time steps.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# select relative maximum error over all time steps\ncompute_error = rel_max_error_overall\nnothing  # hide","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"The results are very similar to those from above. We therefore only show the work-precision diagrams without further comments. The main difference are significantly increased errors which mainly occur around time t = 20 where there is a sharp kink in the solution.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                               compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :topright,\n          color = permutedims([repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)...]),\n          xlims = (10^-5, 10^4), xticks = 10.0 .^ (-5:1:4),\n          ylims = (10^-6, 10^-1), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 4)...]),\n     xlims = (10^-5, 10^4), xticks = 10.0 .^ (-5:1:4),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-6:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 5)...,5, repeat([6], 1)...,repeat([7],2)...]),\n     xlims = (10^-7, 10^5), xticks = 10.0 .^ (-7:1:5),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-6:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/#Fixed-time-step-sizes","page":"NPZD model","title":"Fixed time step sizes","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Here we use fixed time step sizes instead of adaptive time stepping. Similar to the adaptive situation above, standard schemes are likely to compute negative solutions for the NPZD problem.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"sol_Ros23 = solve(prob, Rosenbrock23(), dt = 1.0, adaptive = false);\nsol_MPRK = solve(prob, MPRK22(1.0), dt = 1.0, adaptive = false);\n\np1 = npzd_plot(sol_Ros23, ref_sol, \"Rosenbrock23\");\np2 = npzd_plot(sol_MPRK, ref_sol, \"MPRK22(1.0)\");\nplot(p1, p2)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"We use the functions work_precision_fixed and work_precision_fixed! to compute the data for the diagrams. Please note that these functions set error and computing time to Inf, whenever a solution contains negative elements. Consequently, such cases are not visible in the work-precision diagrams.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Within the work-precision diagrams we use the following time step sizes.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# set time step sizes\ndts = 1.0 ./ 2.0 .^ (0:1:12)\nnothing # hide","category":"page"},{"location":"npzd_model_benchmark/#Relative-maximum-error-at-the-end-of-the-problem's-time-span","page":"NPZD model","title":"Relative maximum error at the end of the problem's time span","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Again, we start with the relative maximum error at the final time t = 100.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing  # hide","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"First, we compare different MPRK methods. For fixed time step sizes we can also consider MPE() and SSPMPRK43().","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# choose MPRK methods to compare\nalgs = [MPE(); algs; SSPMPRK43()]\nlabels = [\"MPE()\"; labels; \"SSPMPRK43\"]\n\n# compute work-precision data\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref;\n                          compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :bottomleft,\n     color = permutedims([5,repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)...,6]),\n     xlims = (10^-10, 1*10^0), xticks = 10.0 .^ (-10:1:0),\n     ylims = (1*10^-6, 10^-1), yticks = 10.0 .^ (-6:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Apart from MPE() the schemes behave very similar and a difference in order can only be observed for the smaller step sizes. We choose MPRK22(1.0) and MPRK43I(1.0, 0.5) for comparisons with other second- and third-order schemes from OrdinaryDiffEq.jl.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# compute work-precision data\nwp = work_precision_fixed(prob, [algs1; algs2], [labels1; labels2], dts, alg_ref;\n                               compute_error)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5],4)...,repeat([6],4)...]),\n     xlims = (10^-13, 10^2), xticks = 10.0 .^ (-12:2:6),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"We see that the MPRK schemes are to be preferred for the rather large step sizes Delta t inlbrace 10 05 025 0125rbrace, for which the other schemes cannot provide nonnegative solutions.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# solution computed with MPRK43I(1.0, 0.5) and dt = 0.125\nsol_MPRK = solve(prob, MPRK43I(1.0, 0.5); dt = dts[4], adaptive = false);\n\n# plot solution\nnpzd_plot(sol_MPRK, ref_sol)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"Finally, we show a comparison of MPRK22(1.0), MPRK43I(1.0, 0.5) and recommended solvers from OrdinaryDiffEq.jl.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# compute work-precision data\nwp = work_precision_fixed(prob, [algs1; algs3], [labels1; labels3], dts, alg_ref;\n                               compute_error)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5],4)...,repeat([6],4)...]),\n     xlims = (10^-14, 10^0), xticks = 10.0 .^ (-14:2:10),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/#Relative-maximum-error-over-all-time-steps-2","page":"NPZD model","title":"Relative maximum error over all time steps","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"As for the adaptive schemes, we also show work-precisions diagrams where the error is the relative maximum error over all time steps.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"# select relative maximum error over all time steps\ncompute_error = rel_max_error_overall\nnothing  # hide","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"\n# compute work-precision\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref;\n                               compute_error)\n\n#plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :bottomleft,\n     color = permutedims([5,repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)...,6]),\n     xlims = (10^-4, 10^5), xticks = 10.0 .^ (-4:1:5),\n     ylims = (10^-6, 10^-1), yticks = 10.0 .^ (-6:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"wp = work_precision_fixed(prob, algs1, labels1, dts, alg_ref;\n                               compute_error)\nwork_precision_fixed!(wp, prob, algs2, labels2, dts, alg_ref;\n                     compute_error)\n\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 4)...]),\n     xlims = (10^-4, 10^6), xticks = 10.0 .^ (-12:1:6),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"wp = work_precision_fixed(prob, algs1, labels1, dts, alg_ref;\n                               compute_error)\nwork_precision_fixed!(wp, prob, algs3, labels3, dts, alg_ref;\n                     compute_error)\n\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :bottomleft,\n     color = permutedims([1, 3, repeat([4], 5)..., 5, repeat([7], 3)...]),\n     xlims = (10^-12, 10^6), xticks = 10.0 .^ (-12:2:6),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"npzd_model_benchmark/#Package-versions","page":"NPZD model","title":"Package versions","text":"","category":"section"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"These results were obtained using the following versions.","category":"page"},{"location":"npzd_model_benchmark/","page":"NPZD model","title":"NPZD model","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\",\n            \"OrdinaryDiffEqLowOrderRK\", \"OrdinaryDiffEqSDIRK\",\n            \"OrdinaryDiffEqRosenbrock\", \"OrdinaryDiffEqTsit5\",\n            \"OrdinaryDiffEqVerner\"],\n           mode = PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"robertson_benchmark/#benchmark-robertson","page":"Robertson problem","title":"Benchmark: Solution of the Robertson problem","text":"","category":"section"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Here we use the stiff Robertson problem prob_pds_robertson to assess the efficiency of different solvers from OrdinaryDiffEq.jl and PositiveIntegrators.jl.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"using OrdinaryDiffEqFIRK, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqSDIRK\nusing PositiveIntegrators\n\n# select Robertson problem\nprob = prob_pds_robertson\nnothing # hide","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"To keep the following code as clear as possible, we define a helper function robertson_plot that we use for plotting.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"using Plots\n\nfunction robertson_plot(sol, sol_ref = nothing, title = \"\")\n    colors = palette(:default)[1:3]'\n    if !isnothing(sol_ref)\n        p = plot(sol_ref, tspan = (1e-6, 1e11), xaxis = :log,\n                 idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n                 linestyle = :dash, label = \"\", color = colors, linewidth = 2)\n        plot!(p, sol; tspan = (1e-6, 1e11), xaxis = :log, denseplot = false,\n              markers = :circle, ylims = (-0.2, 1.2),\n              idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n              title, xticks = 10.0 .^ (-6:4:10), color = colors,\n              linewidht = 2, legend = :right, label = [\"u₁\" \"10⁴ u₂\" \"u₃\"])\n    else\n        p = plot(sol; tspan = (1e-6, 1e11), xaxis = :log, denseplot = false,\n                 markers = :circle, ylims = (-0.2, 1.2),\n                 idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n                 title, xticks = 10.0 .^ (-6:4:10), color = colors,\n                 linewidht = 2, legend = :right, label = [\"u₁\" \"10⁴ u₂\" \"u₃\"])\n    end\n    return p\nend\nnothing # hide","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"For this stiff problem the computation of negative approximations may lead to inaccurate solutions. This typically occurs when adaptive time stepping uses loose tolerances.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# compute reference solution for plotting\nref_sol = solve(prob, Rodas4P(); abstol = 1e-14, reltol = 1e-13);\n\n# compute solutions with loose tolerances\nabstol = 1e-2\nreltol = 1e-1\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol);\nsol_MPRK = solve(prob, MPRK22(1.0); abstol, reltol);\n\n# plot solutions\np1 = robertson_plot(sol_Ros23, ref_sol, \"Rosenbrock23\");\np2 = robertson_plot(sol_MPRK, ref_sol, \"MPRK22(1.0)\");\nplot(p1, p2)","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Nevertheless, OrdinaryDiffEq.jl provides the solver option isoutofdomain, which can be used in combination with isnegative to guarantee nonnegative solutions.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"sol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol,\n                  isoutofdomain = isnegative) #reject negative solutions\n\nrobertson_plot(sol_Ros23, ref_sol, \"Rosenbrock23\")","category":"page"},{"location":"robertson_benchmark/#Work-Precision-diagrams","page":"Robertson problem","title":"Work-Precision diagrams","text":"","category":"section"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"In the following we show several work-precision diagrams, which compare different methods with respect to computing time and the respective error. We focus solely on adaptive methods, since the time interval (0 10^11) is too large to generate accurate solutions with fixed step sizes.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Since the Robertson problem is stiff, we need to use a suited implicit scheme to compute a reference solution, see the solver guide. Note that we cannot use the recommended method radau(), since prob_pds_robertson uses StaticArrays.jl instead of standard Arrays.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# select solver to compute reference solution\nalg_ref = Rodas4P()\nnothing # hide","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"We use the functions work_precision_adaptive and work_precision_adaptive! to compute the data for the diagrams. Furthermore, the following absolute and relative tolerances are used.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# set absolute and relative tolerances\nabstols = 1.0 ./ 10.0 .^ (2:1:10)\nreltols = abstols .* 10.0\nnothing # hide","category":"page"},{"location":"robertson_benchmark/#Relative-maximum-error-at-the-final-time","page":"Robertson problem","title":"Relative maximum error at the final time","text":"","category":"section"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"In this section the chosen error is the relative maximum error at the final time t = 10^11.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing # hide","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"We start with a comparison of different adaptive MPRK schemes.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# choose methods to compare\nalgs = [MPRK22(0.5); MPRK22(2.0 / 3.0); MPRK22(1.0); MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75);\n        MPRK43II(0.5); MPRK43II(2.0 / 3.0)]\nlabels = [\"MPRK22(0.5)\"; \"MPRK22(2/3)\"; \"MPRK22(1.0)\"; \"MPRK43I(1.0,0.5)\"; \"MPRK43I(0.5,0.75)\";\n         \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                            adaptive_ref = true, compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Robertson benchmark\", legend = :topright,\n     color = permutedims([repeat([1], 3)..., repeat([3], 2)..., repeat([4], 2)...]),\n     xlims = (10^-10, 10^0), xticks = 10.0 .^ (-10:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"We see that the second- and third-order schemes perform very similar, except for MPRK22(0.5). This superior performance of MPRK22(0.5) cannot be seen in other benchmarks; it is, therefore, an exception here.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"The scheme SSPMPRK22(0.5, 1.0) has not been considered above, since it generates oscillatory solutions.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"sol1 = solve(prob, SSPMPRK22(0.5, 1.0), abstol=1e-5, reltol = 1e-4);\n\n# plot solutions\nrobertson_plot(sol1, ref_sol, \"SSPMPRK22(0.5, 1.0)\")","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"For comparisons with schemes from OrdinaryDiffEq.jl, we choose the second-order schemes MPRK22(0.5) and MPRK22(1.0) as well as the third-order scheme MPRK43I(0.5, 0.75).","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"sol_MPRK22_½ = solve(prob, MPRK22(0.5); abstol, reltol)\nsol_MPRK22_1 = solve(prob, MPRK22(1.0); abstol, reltol)\nsol_MPRK43 = solve(prob, MPRK43I(0.5, 0.75); abstol, reltol)\n\np1 = robertson_plot(sol_MPRK22_½, ref_sol, \"MPRK22(0.5)\");\np2 = robertson_plot(sol_MPRK22_1, ref_sol, \"MPRK22(1.0)\");\np3 = robertson_plot(sol_MPRK43, ref_sol, \"MPRK43I(0.5, 0.75)\");\nplot(p1, p2, p3)","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Now we compare these three schemes with a selection of second- and third-order stiff solvers from OrdinaryDiffEq.jl. To guarantee nonnegative solutions, we use the solver option isoutofdomain = isnegative.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# select reference MPRK methods\nalgs1 = [MPRK22(0.5); MPRK22(1.0); MPRK43I(0.5, 0.75)]\nlabels1 = [\"MPRK22(0.5)\"; \"MPRK22(1.0)\"; \"MPRK43I(0.5,0.75)\"]\n\n# select methods from OrdinaryDiffEq\nalgs2 = [TRBDF2(); Kvaerno3(); KenCarp3(); Rodas3(); ROS2(); ROS3(); Rosenbrock23()]\nlabels2 = [\"TRBDF2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\"; \"ROS2\"; \"ROS3\"; \"Rosenbrock23\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"Robertson benchmark\", legend = :topright,\n     color = permutedims([repeat([1], 2)..., 3, repeat([5], 3)..., repeat([6], 4)...]),\n     xlims = (10^-10, 10^3), xticks = 10.0 .^ (-14:1:3),\n     ylims = (10^-6, 10^1), yticks = 10.0 .^ (-6:1:0), minorticks = 10)","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"We see that MPRK22(1.0) and MPRK43I(0.5, 0.75) perform similar to Ros3() or Rosenbrock23() and are a good choice as long as low accuracy is acceptable. For high accuracy we should employ a scheme like KenCarp3(). As for MPRK22(0.5) the  superior performance of Rodas3() seems to be an exception here.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"In addition,  we compare MPRK22(1.0) and MPRK43I(0.5, 0.75) to some recommended solvers of higher order from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"algs3 = [Rodas5P(); Rodas4P(); RadauIIA5()]\nlabels3 = [\"Rodas5P\"; \"Rodas4P\"; \"RadauIIA5\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"Robertson benchmark\", legend = :topright,\n     color = permutedims([repeat([1],2)..., 3, repeat([4], 2)..., 5]),\n     xlims = (10^-10, 2*10^0), xticks = 10.0 .^ (-10:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Again, we see that the MPRK schemes are in general only beneficial if low accuracy is acceptable.","category":"page"},{"location":"robertson_benchmark/#Relative-maximum-error-over-all-time-steps","page":"Robertson problem","title":"Relative maximum error over all time steps","text":"","category":"section"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"In this section we do not compare the relative maximum errors at the final time t = 10^11, but the relative maximum errors over all time steps.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_overall\nnothing # hide","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"First, we compare different MPRK schemes. As above, we omit SSPMPRK22(0.5, 1.0).","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                            adaptive_ref = true, compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Robertson benchmark\", legend = :top,\n     color = permutedims([repeat([1], 3)..., repeat([3], 2)..., repeat([4], 2)...]),\n     xlims = (10^-4, 5*10^1), xticks = 10.0 .^ (-5:1:2),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Notably, the error of the second-order methods does not decrease when stricter tolerances are used. We choose the second-order scheme MPRK22(1.0) and the third-order scheme MPRK43I(0.5, 0.75) for comparison with solvers from OrdinaryDiffEq.jl. To guarantee nonnegative solutions of these methods, we select the solver option isoutofdomain = isnegative.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# select reference MPRK methods\nalgs1 = [MPRK22(1.0); MPRK43I(0.5, 0.75)]\nlabels1 = [\"MPRK22(1.0)\"; \"MPRK43I(0.5,0.75)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"Robertson benchmark\", legend = :bottomleft,\n     color = permutedims([1, 3, repeat([5], 3)..., repeat([6], 4)...]),\n     xlims = (10^-5, 10^2), xticks = 10.0 .^ (-14:1:3),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Here too, some methods show that the error does not decrease even though stricter tolerances are used.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"Finally, we compare MPRK43I(0.5, 0.75) and MPRK22(1.0) to recommended solvers of higher order from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"Robertson benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 2)..., 5]),\n     xlims = (10^-4, 2*10^0), xticks = 10.0 .^ (-11:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"page"},{"location":"robertson_benchmark/#Package-versions","page":"Robertson problem","title":"Package versions","text":"","category":"section"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"These results were obtained using the following versions.","category":"page"},{"location":"robertson_benchmark/","page":"Robertson problem","title":"Robertson problem","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\",\n            \"OrdinaryDiffEqFIRK\", \"OrdinaryDiffEqRosenbrock\",\n            \"OrdinaryDiffEqSDIRK\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"heat_equation_dirichlet/#tutorial-heat-equation-dirichlet","page":"Heat Equation, Dirichlet BCs","title":"Tutorial: Solution of the heat equation with Dirichlet boundary conditions","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"We continue the previous tutorial on solving the heat equation with Neumann boundary conditions by looking at Dirichlet boundary conditions instead, resulting in a non-conservative production-destruction system.","category":"page"},{"location":"heat_equation_dirichlet/#Definition-of-the-(non-conservative)-production-destruction-system","page":"Heat Equation, Dirichlet BCs","title":"Definition of the (non-conservative) production-destruction system","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"Consider the heat equation","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"partial_t u(tx) = mu partial_x^2 u(tx)quad u(0x)=u_0(x)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"with μ  0, t 0, xin01, and homogeneous Dirichlet boundary conditions. We use again a finite volume discretization, i.e., we split the domain 0 1 into N uniform cells of width Delta x = 1  N. As degrees of freedom, we use the mean values of u(t) in each cell approximated by the point value u_i(t) in the center of cell i. Finally, we use the classical central finite difference discretization of the Laplacian with homogeneous Dirichlet boundary conditions, resulting in the ODE","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"partial_t u(t) = L u(t)\nquad\nL = fracmuDelta x^2 beginpmatrix\n    -2  1 \n    1  -2  1 \n     ddots  ddots  ddots \n     1  -2  1 \n     1  -2\nendpmatrix","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"The system can be written as a non-conservative PDS with production terms","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"beginaligned\np_ii-1(tmathbf u(t)) = fracmuDelta x^2 u_i-1(t)quad i=2dotsN \np_ii+1(tmathbf u(t)) = fracmuDelta x^2 u_i+1(t)quad i=1dotsN-1\nendaligned","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"and destruction terms d_ij = p_ji for i ne j as well as the non-conservative destruction terms","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"beginaligned\nd_11(tmathbf u(t)) = fracmuDelta x^2 u_1(t) \nd_NN(tmathbf u(t)) = fracmuDelta x^2 u_N(t)\nendaligned","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"In addition, all production and destruction terms not listed are zero.","category":"page"},{"location":"heat_equation_dirichlet/#Solution-of-the-non-conservative-production-destruction-system","page":"Heat Equation, Dirichlet BCs","title":"Solution of the non-conservative production-destruction system","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"Now we are ready to define a PDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use N = 100 nodes and the time domain t in 01. Moreover, we choose the initial condition","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"u_0(x) = sin(pi x)^2","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"x_boundaries = range(0, 1, length = 101)\nx = x_boundaries[1:end-1] .+ step(x_boundaries) / 2\nu0 = @. sinpi(x)^2 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"We will choose three different matrix types for the production terms and the resulting linear systems:","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"standard dense matrices (default)\nsparse matrices (from SparseArrays.jl)\ntridiagonal matrices (from LinearAlgebra.jl)","category":"page"},{"location":"heat_equation_dirichlet/#Standard-dense-matrices","page":"Heat Equation, Dirichlet BCs","title":"Standard dense matrices","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction heat_eq_P!(P, u, μ, t)\n    fill!(P, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    let i = 1\n        # Dirichlet boundary condition\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    for i in 2:(length(u) - 1)\n        # interior stencil\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    let i = length(u)\n        # Dirichlet boundary condition\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n    end\n\n    return nothing\nend\n\nfunction heat_eq_D!(D, u, μ, t)\n    fill!(D, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    # Dirichlet boundary condition\n    D[begin] = u[begin] * μ_Δx2\n    D[end] = u[end] * μ_Δx2\n\n    return nothing\nend\n\nμ = 1.0e-2\nprob = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ) # create the PDS\n\nsol = solve(prob, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"page"},{"location":"heat_equation_dirichlet/#Sparse-matrices","page":"Heat Equation, Dirichlet BCs","title":"Sparse matrices","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"To use different matrix types for the production terms and linear systems, you can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), length(u0) - 1),\n                      +1 => ones(eltype(u0), length(u0) - 1))\nprob_sparse = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ;\n                         p_prototype = p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"page"},{"location":"heat_equation_dirichlet/#Tridiagonal-matrices","page":"Heat Equation, Dirichlet BCs","title":"Tridiagonal matrices","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"The sparse matrices used in this case have a very special structure since they are in fact tridiagonal matrices. Thus, we can also use the special matrix type Tridiagonal from the standard library LinearAlgebra.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using LinearAlgebra\np_prototype = Tridiagonal(ones(eltype(u0), length(u0) - 1),\n                          ones(eltype(u0), length(u0)),\n                          ones(eltype(u0), length(u0) - 1))\nprob_tridiagonal = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ;\n                              p_prototype = p_prototype)\n\nsol_tridiagonal = solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_tridiagonal.u); label = \"u\")","category":"page"},{"location":"heat_equation_dirichlet/#Performance-comparison","page":"Heat Equation, Dirichlet BCs","title":"Performance comparison","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using BenchmarkTools\n@benchmark solve(prob, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"@benchmark solve(prob_sparse, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"By default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized  for. Thus, it is often possible to gain performance by switching to KLU  instead.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using LinearSolve\n@benchmark solve(prob_sparse, MPRK22(1.0; linsolve = KLUFactorization()); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"@benchmark solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/#Package-versions","page":"Heat Equation, Dirichlet BCs","title":"Package versions","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"These results were obtained using the following versions.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"robertson/#tutorial-robertson","page":"Robertson problem","title":"Tutorial: Solution of Robertson problem","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"In this tutorial we show that MPRK schemes can be used to integrate stiff problems. We also show how callbacks can be used to change the time step in non-adaptive schemes.","category":"page"},{"location":"robertson/#Definition-of-the-production-destruction-system","page":"Robertson problem","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The well known Robertson problem is given by","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"beginaligned\nu_1 = -004u_1+10^4 u_2u_3  u_1(0)=1\nu_2 =  004u_1-10^4 u_2u_3-310^7 u_2^2  u_2(0)=0 \nu_3 = 310^7 u_2^2  u_3(0)=0\nendaligned","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The time domain of interest is tin010^11, because of which some kind of adaptive time stepping is required.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The model can be represented as a conservative PDS with production terms","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"beginaligned\np_12(tmathbfu) = 10^4u_2u_3\np_21(tmathbfu) = 004u_1 \np_32(tmathbfu) = 310^7u_2^2\nendaligned","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"whereby production terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix mathbf P=(p_ij).","category":"page"},{"location":"robertson/#Solution-of-the-production-destruction-system","page":"Robertson problem","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with any method of PositiveIntegrators.jl or OrdinaryDiffEq.jl which is suited for stiff problems.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"Since this PDS consists of only three differential equations we provide an out-of-place implementation for the production matrix. Furthermore, we use static arrays from StaticArrays.jl for additional efficiency. See also the tutorials on the solution of an NPZD model or an stratospheric reaction problem.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using PositiveIntegrators, StaticArrays\n\nfunction prod(u, p, t)\n    @SMatrix [0.0 1e4*u[2]*u[3] 0.0;\n              4e-2*u[1] 0.0 0.0;\n              0.0 3e7*u[2]^2 0.0]\nend\nu0 = @SVector [1.0, 0.0, 0.0]\ntspan = (0.0, 1.0e11)\nprob = ConservativePDSProblem(prod, u0, tspan)\n\nsol = solve(prob, MPRK43I(1.0, 0.5))\nnothing  # hide","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using Plots\n\nplot(sol, tspan = (1e-6, 1e11),  xaxis = :log,\n     idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n     label = [\"u₁\" \"10⁴u₂\" \"u₃\"])","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"PositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"isnonnegative(sol)","category":"page"},{"location":"robertson/#Using-callbacks-to-solve-the-Robertson-problem-with-non-adatpive-schemes","page":"Robertson problem","title":"Using callbacks to solve the Robertson problem with non-adatpive schemes","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The SSPMPRK43() scheme is only available with fixed time stepping. With a scheme like this, it would take a huge amount of time to solve the Robertson problem, since the time step must be chosen very small to accurately solve the problem in its initial phase. However, the use of a callback allows us to modify the time step size after each step, which makes a solution with a fixed step method possible.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"In the following example the callback increases the time step size by a factor of 1.5 after each time step.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using DiffEqCallbacks\nusing DiffEqBase\n\nstepsize_callback = DiscreteCallback(\n    Returns(true), # adapt the step size after every time step\n    integrator -> set_proposed_dt!(integrator, 1.5 * get_proposed_dt(integrator));\n    save_positions = (false, false),\n    initialize = (c, u, t, integrator) -> set_proposed_dt!(integrator, 1.0e-5))\nsol_cb = solve(prob, SSPMPRK43(); dt = Inf, callback =  stepsize_callback);\nnothing  # hide","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"plot(sol_cb, tspan = (1e-6, 1e11),  xaxis = :log,\n     idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n     label = [\"u₁\" \"10⁴u₂\" \"u₃\"])","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"This solution is also nonnegative.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"isnonnegative(sol_cb)","category":"page"},{"location":"robertson/#Package-versions","page":"Robertson problem","title":"Package versions","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"These results were obtained using the following versions.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\", \"DiffEqCallbacks\", \"DiffEqBase\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"faq/#Troubleshooting-and-frequently-asked-questions","page":"Troubleshooting, FAQ","title":"Troubleshooting and frequently asked questions","text":"","category":"section"},{"location":"faq/#Sparse-matrices","page":"Troubleshooting, FAQ","title":"Sparse matrices","text":"","category":"section"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"You can use sparse matrices for the linear systems arising in PositiveIntegrators.jl, as described, e.g., in the tutorial on linear advection. However, you need to make sure that you do not change the sparsity pattern of the production term matrix since we assume that the structural nonzeros are kept fixed. This is a known issue. For example, you should avoid something like","category":"page"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"using SparseArrays\np = spdiagm(0 => ones(4), 1 => zeros(3))\np .= 2 * p","category":"page"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"Instead, you should be able to use a pattern like the following, where the function nonzeros is used to modify the values of a sparse matrix.","category":"page"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"using SparseArrays\np = spdiagm(0 => ones(4), 1 => zeros(3))\nfor j in axes(p, 2)\n    for idx in nzrange(p, j)\n        i = rowvals(p)[idx]\n        nonzeros(p)[idx] = 10 * i + j # value p[i, j]\n    end\nend; p","category":"page"},{"location":"convergence/#convergence_mprk","page":"Experimental order of convergence","title":"Experimental convergence order of MPRK schemes","text":"","category":"section"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"In this tutorial, we check that the implemented MPRK schemes have the expected order of convergence. ","category":"page"},{"location":"convergence/#Conservative-production-destruction-systems","page":"Experimental order of convergence","title":"Conservative production-destruction systems","text":"","category":"section"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"First, we consider conservative production-destruction systems (PDS). To investigate the convergence order, we define the non-autonomous test problem ","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"beginaligned\nu_1 = cos(pi t)^2 u_2 - sin(2pi t)^2 u_1  u_1(0)=09 \nu_2  = sin(2pi t)^2 u_1 - cos(pi t)^2 u_2  u_2(0)=01\nendaligned","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"for 0 t 1. The PDS is conservative since the sum of the right-hand side terms equals zero.  An implementation of the problem is given next.","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"using PositiveIntegrators\n\n# define problem\nP(u, p, t) = [0.0 cos.(π * t) .^ 2 * u[2]; sin.(2 * π * t) .^ 2 * u[1] 0.0]\nprob = ConservativePDSProblem(P, [0.9; 0.1], (0.0, 1.0))\n\nnothing # hide","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"To use analyticless_test_convergence from DiffEqDevTools.jl, we need to pick a solver to compute the reference solution and specify tolerances. Since the problem is not stiff, we use the high-order explicit solver Vern9() from OrdinaryDiffEqVerner.jl. Moreover, we choose time step sizes to investigate the convergence behavior. ","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"using OrdinaryDiffEqVerner\nusing DiffEqDevTools: analyticless_test_convergence\n\n# solver and tolerances to compute reference solution\ntest_setup = Dict(:alg => Vern9(), :reltol => 1e-14, :abstol => 1e-14)\n\n# choose step sizes\ndts = 0.5 .^ (5:10)\n\nnothing # hide","category":"page"},{"location":"convergence/#Second-order-MPRK-schemes","page":"Experimental order of convergence","title":"Second-order MPRK schemes","text":"","category":"section"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"First, we test several second-order MPRK schemes.","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"# select schemes\nalgs2 = [MPRK22(0.5); MPRK22(2.0 / 3.0); MPRK22(1.0); SSPMPRK22(0.5, 1.0)]\nlabels2 = [\"MPRK22(0.5)\"; \"MPRK22(2.0/3.0)\"; \"MPRK22(1.0)\"; \"SSPMPRK22(0.5, 1.0)\"]\n\n# compute errors and experimental order of convergence\nerr_eoc = []\nfor i in eachindex(algs2)\n     sim = analyticless_test_convergence(dts, prob, algs2[i], test_setup)\n\n     err = sim.errors[:l∞]\n     eoc = [NaN; -log2.(err[2:end] ./ err[1:(end - 1)])]\n\n     push!(err_eoc, tuple.(err, eoc))\nend","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"Next, we print a table with the computed data. The table lists the errors obtained with the respective time step size Δ t as well as the estimated order of convergence in parentheses.","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"using Printf: @sprintf\nusing PrettyTables: pretty_table\n\n# gather data for table\ndata = hcat(dts, reduce(hcat,err_eoc))\n\n# print table\nformatter = (v, i, j) ->  (j>1) ? (@sprintf \"%5.2e (%4.2f) \" v[1] v[2]) : (@sprintf \"%5.2e \" v)\npretty_table(data, formatters = formatter, header = [\"Δt\"; labels2])                  ","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"The table shows that all schemes converge as expected.","category":"page"},{"location":"convergence/#Third-order-MPRK-schemes","page":"Experimental order of convergence","title":"Third-order MPRK schemes","text":"","category":"section"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"In this section, we proceed as above, but consider third-order MPRK schemes instead.","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"# select 3rd order schemes\nalgs3 = [MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75); MPRK43II(0.5); MPRK43II(2.0 / 3.0); \n         SSPMPRK43()]\nlabels3 = [\"MPRK43I(1.0,0.5)\"; \"MPRK43I(0.5, 0.75)\"; \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\";\n          \"SSPMPRK43()\"]\n\n# compute errors and experimental order of convergence\nerr_eoc = []\nfor i in eachindex(algs3)\n     sim = analyticless_test_convergence(dts, prob, algs3[i], test_setup)\n\n     err = sim.errors[:l∞]\n     eoc = [NaN; -log2.(err[2:end] ./ err[1:(end - 1)])]\n\n     push!(err_eoc, tuple.(err, eoc))\nend\n\n# gather data for table\ndata = hcat(dts, reduce(hcat,err_eoc))\n\n# print table\nformatter = (v, i, j) ->  (j>1) ? (@sprintf \"%5.2e (%4.2f) \" v[1] v[2]) : (@sprintf \"%5.2e \" v)\npretty_table(data, formatters = formatter, header = [\"Δt\"; labels3])  ","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"As above, the table shows that all schemes converge as expected.","category":"page"},{"location":"convergence/#Non-conservative-PDS","page":"Experimental order of convergence","title":"Non-conservative PDS","text":"","category":"section"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"In this section we consider the non-autonomous but non-conservative test problem ","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"beginaligned\nu_1 = cos(pi t)^2 u_2 - sin(2pi t)^2 u_1 - cos(2pi t)^2 u_1  u_1(0)=09\nu_2  = sin(2pi t)^2 u_1 - cos(pi t)^2 u_2 - sin(pi t)^2 u_2  u_2(0)=01\nendaligned","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"for 0 t 1. Since the sum of the right-hand side terms does not cancel, the PDS is indeed non-conservative. Hence, we need to use PDSProblem for its implementation.","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"# choose problem\nP(u, p, t) = [0.0 cos.(π * t) .^ 2 * u[2]; sin.(2 * π * t) .^ 2 * u[1] 0.0]\nD(u, p, t) = [cos.(2 * π * t) .^ 2 * u[1]; sin.(π * t) .^ 2 * u[2]]\nprob = PDSProblem(P, D, [0.9; 0.1], (0.0, 1.0))\n\nnothing # hide","category":"page"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"The following sections will show that the selected MPRK schemes show the expected convergence order also for this non-conservative PDS.","category":"page"},{"location":"convergence/#Second-order-MPRK-schemes-2","page":"Experimental order of convergence","title":"Second-order MPRK schemes","text":"","category":"section"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"# compute errors and experimental order of convergence\nerr_eoc = []\nfor i in eachindex(algs2)\n     sim = analyticless_test_convergence(dts, prob, algs2[i], test_setup)\n\n     err = sim.errors[:l∞]\n     eoc = [NaN; -log2.(err[2:end] ./ err[1:(end - 1)])]\n\n     push!(err_eoc, tuple.(err, eoc))\nend\n\n# gather data for table\ndata = hcat(dts, reduce(hcat,err_eoc))\n\n# print table\nformatter = (v, i, j) ->  (j>1) ? (@sprintf \"%5.2e (%4.2f) \" v[1] v[2]) : (@sprintf \"%5.2e \" v)\npretty_table(data, formatters = formatter, header = [\"Δt\"; labels2])                  ","category":"page"},{"location":"convergence/#Third-order-MPRK-schemes-2","page":"Experimental order of convergence","title":"Third-order MPRK schemes","text":"","category":"section"},{"location":"convergence/","page":"Experimental order of convergence","title":"Experimental order of convergence","text":"# compute errors and experimental order of convergence\nerr_eoc = []\nfor i in eachindex(algs3)\n     sim = analyticless_test_convergence(dts, prob, algs3[i], test_setup)\n\n     err = sim.errors[:l∞]\n     eoc = [NaN; -log2.(err[2:end] ./ err[1:(end - 1)])]\n\n     push!(err_eoc, tuple.(err, eoc))\nend\n\n# gather data for table\ndata = hcat(dts, reduce(hcat,err_eoc))\n\n# print table\nformatter = (v, i, j) ->  (j>1) ? (@sprintf \"%5.2e (%4.2f) \" v[1] v[2]) : (@sprintf \"%5.2e \" v)\npretty_table(data, formatters = formatter, header = [\"Δt\"; labels3])  ","category":"page"},{"location":"heat_equation_neumann/#tutorial-heat-equation-neumann","page":"Heat Equation, Neumann BCs","title":"Tutorial: Solution of the heat equation with Neumann boundary conditions","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Similar to the tutorial on linear advection, we will demonstrate how to solve a conservative production-destruction system (PDS) resulting from a PDE discretization and means to improve the performance.","category":"page"},{"location":"heat_equation_neumann/#Definition-of-the-conservative-production-destruction-system","page":"Heat Equation, Neumann BCs","title":"Definition of the conservative production-destruction system","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Consider the heat equation","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"partial_t u(tx) = mu partial_x^2 u(tx)quad u(0x)=u_0(x)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"with μ  0, t 0, xin01, and homogeneous Neumann boundary conditions. We use a finite volume discretization, i.e., we split the domain 0 1 into N uniform cells of width Delta x = 1  N. As degrees of freedom, we use the mean values of u(t) in each cell approximated by the point value u_i(t) in the center of cell i. Finally, we use the classical central finite difference discretization of the Laplacian with homogeneous Neumann boundary conditions, resulting in the ODE","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"partial_t u(t) = L u(t)\nquad\nL = fracmuDelta x^2 beginpmatrix\n    -1  1 \n    1  -2  1 \n     ddots  ddots  ddots \n     1  -2  1 \n     1  -1\nendpmatrix","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"The system can be written as a conservative PDS with production terms","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"beginaligned\np_ii-1(tmathbf u(t)) = fracmuDelta x^2 u_i-1(t)quad i=2dotsN \np_ii+1(tmathbf u(t)) = fracmuDelta x^2 u_i+1(t)quad i=1dotsN-1\nendaligned","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"and destruction terms d_ij = p_ji. In addition, all production and destruction terms not listed are zero.","category":"page"},{"location":"heat_equation_neumann/#Solution-of-the-conservative-production-destruction-system","page":"Heat Equation, Neumann BCs","title":"Solution of the conservative production-destruction system","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use N = 100 nodes and the time domain t in 01. Moreover, we choose the initial condition","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"u_0(x) = cos(pi x)^2","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"x_boundaries = range(0, 1, length = 101)\nx = x_boundaries[1:end-1] .+ step(x_boundaries) / 2\nu0 = @. cospi(x)^2 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"We will choose three different matrix types for the production terms and the resulting linear systems:","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"standard dense matrices (default)\nsparse matrices (from SparseArrays.jl)\ntridiagonal matrices (from LinearAlgebra.jl)","category":"page"},{"location":"heat_equation_neumann/#Standard-dense-matrices","page":"Heat Equation, Neumann BCs","title":"Standard dense matrices","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction heat_eq_P!(P, u, μ, t)\n    fill!(P, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    let i = 1\n        # Neumann boundary condition\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    for i in 2:(length(u) - 1)\n        # interior stencil\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    let i = length(u)\n        # Neumann boundary condition\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n    end\n\n    return nothing\nend\n\nμ = 1.0e-2\nprob = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ) # create the PDS\n\nsol = solve(prob, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"page"},{"location":"heat_equation_neumann/#Sparse-matrices","page":"Heat Equation, Neumann BCs","title":"Sparse matrices","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"To use different matrix types for the production terms and linear systems, you can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), length(u0) - 1),\n                      +1 => ones(eltype(u0), length(u0) - 1))\nprob_sparse = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ;\n                                     p_prototype = p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"page"},{"location":"heat_equation_neumann/#Tridiagonal-matrices","page":"Heat Equation, Neumann BCs","title":"Tridiagonal matrices","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"The sparse matrices used in this case have a very special structure since they are in fact tridiagonal matrices. Thus, we can also use the special matrix type Tridiagonal from the standard library LinearAlgebra.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using LinearAlgebra\np_prototype = Tridiagonal(ones(eltype(u0), length(u0) - 1),\n                          ones(eltype(u0), length(u0)),\n                          ones(eltype(u0), length(u0) - 1))\nprob_tridiagonal = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ;\n                                          p_prototype = p_prototype)\n\nsol_tridiagonal = solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_tridiagonal.u); label = \"u\")","category":"page"},{"location":"heat_equation_neumann/#Performance-comparison","page":"Heat Equation, Neumann BCs","title":"Performance comparison","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using BenchmarkTools\n@benchmark solve(prob, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"@benchmark solve(prob_sparse, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"By default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized  for. Thus, it is often possible to gain performance by switching to KLU  instead.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using LinearSolve\n@benchmark solve(prob_sparse, MPRK22(1.0; linsolve = KLUFactorization()); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"@benchmark solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/#Package-versions","page":"Heat Equation, Neumann BCs","title":"Package versions","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"These results were obtained using the following versions.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"code_of_conduct/","page":"Code of conduct","title":"Code of conduct","text":"EditURL = \"https://github.com/NumericalMathematics/PositiveIntegrators.jl/blob/main/CODE_OF_CONDUCT.md\"","category":"page"},{"location":"code_of_conduct/#code-of-conduct","page":"Code of conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of conduct","title":"Code of conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Stefan Kopecz or Hendrik Ranocha. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"linear_advection/#tutorial-linear-advection","page":"Linear Advection","title":"Tutorial: Solution of the linear advection equation","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"This tutorial is about the efficient solution of production-destruction systems (PDS) with a large number of differential equations. We will explore several ways to represent such large systems and assess their efficiency.","category":"page"},{"location":"linear_advection/#Definition-of-the-production-destruction-system","page":"Linear Advection","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"One example of the occurrence of a PDS with a large number of equations is the space discretization of a partial differential equation. In this tutorial we want to solve the linear advection equation","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"partial_t u(tx)=-apartial_x u(tx)quad u(0x)=u_0(x)","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"with a0, t 0, xin01 and periodic boundary conditions. To keep things as simple as possible, we discretize the space domain as 0=x_0x_1dots x_N-1x_N=1 with x_i = i Δ x for i=0dotsN and Δx=1N. An upwind discretization of the spatial derivative yields the ODE system","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"beginaligned\npartial_t u_1(t) =-fracaΔxbigl(u_1(t)-u_N(t)bigr)\npartial_t u_i(t) =-fracaΔxbigl(u_i(t)-u_i-1(t)bigr)quad i=2dotsN\nendaligned","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"where u_i(t) is an approximation of u(tx_i) for i=1dots N. This system can also be written as partial_t mathbf u(t)=mathbf Amathbf u(t) with mathbf u(t)=(u_1(t)dotsu_N(t)) and","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"mathbf A= fracaΔ xbeginbmatrix-10dots011-1ddots00ddotsddotsddotsvdots vdotsddotsddotsddots00dots01-1endbmatrix","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"In particular the matrix mathbf A shows that there is a single production term and a single destruction term per equation. Furthermore, the system is conservative as mathbf A has column sum zero. To be precise, the production matrix mathbf P = (p_ij) of this conservative PDS is given by","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"beginaligned\np_1N(tmathbf u(t)) = fracaΔ xu_N(t)\np_ii-1(tmathbf u(t)) = fracaΔ xu_i-1(t)quad i=2dotsN\nendaligned","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"In addition, all production and destruction terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix mathbf P.","category":"page"},{"location":"linear_advection/#Solution-of-the-production-destruction-system","page":"Linear Advection","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use a=1, N=1000 and the time domain tin01. Moreover, we choose the step function","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"u_0(x)=begincases1  04  x  06 0 textelsewhereendcases","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"as initial condition. Due to the periodic boundary conditions and the transport velocity a=1, the solution at time t=1 is identical to the initial distribution, i.e. u(1x) = u_0(x).","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"N = 1000 # number of subintervals\ndx = 1/N # mesh width\nx = LinRange(dx, 1.0, N) # discretization points x_1,...,x_N = x_0\nu0 = @. 0.0 + (0.4 ≤ x ≤ 0.6) * 1.0 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"As mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"an in-place implementation with a dense matrix,\nan in-place implementation with a sparse matrix.","category":"page"},{"location":"linear_advection/#Standard-in-place-implementation","page":"Linear Advection","title":"Standard in-place implementation","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"By default, we will use dense matrices to store the production terms and to setup/solve the linear systems arising in MPRK methods. Of course, this is not efficient for large and sparse systems like in this case.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction lin_adv_P!(P, u, p, t)\n    fill!(P, 0.0)\n    N = length(u)\n    dx = 1 / N\n    P[1, N] = u[N] / dx\n    for i in 2:N\n        P[i, i - 1] = u[i - 1] / dx\n    end\n    return nothing\nend\n\nprob = ConservativePDSProblem(lin_adv_P!, u0, tspan) # create the PDS\n\nsol = solve(prob, MPRK43I(1.0, 0.5); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"We can use isnonnegative to check that the computed solution is nonnegative,  as expected from an MPRK scheme.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"isnonnegative(sol)","category":"page"},{"location":"linear_advection/#Using-sparse-matrices","page":"Linear Advection","title":"Using sparse matrices","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"To use different matrix types for the production terms and linear systems, we can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), N - 1),\n                      N - 1 => ones(eltype(u0), 1))\nprob_sparse = ConservativePDSProblem(lin_adv_P!, u0, tspan; p_prototype=p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK43I(1.0, 0.5); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"plot(x,u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"Also this solution is nonnegative.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"isnonnegative(sol_sparse)","category":"page"},{"location":"linear_advection/#Performance-comparison","page":"Linear Advection","title":"Performance comparison","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using BenchmarkTools\n@benchmark solve(prob, MPRK43I(1.0, 0.5); save_everystep = false)","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"@benchmark solve(prob_sparse, MPRK43I(1.0, 0.5); save_everystep = false)","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"By default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized for. Thus, it is often possible to gain performance by switching to KLU instead.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using LinearSolve\n@benchmark solve(prob_sparse, MPRK43I(1.0, 0.5; linsolve = KLUFactorization()); save_everystep = false)","category":"page"},{"location":"linear_advection/#Package-versions","page":"Linear Advection","title":"Package versions","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"These results were obtained using the following versions.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"stratospheric_reaction/#tutorial-stratos","page":"Stratospheric reaction problem","title":"Tutorial: Solution of a stratospheric reaction problem","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"This tutorial is about the efficient solution of a stiff non-autonomous and non-conservative production-destruction systems (PDS) with a small number of differential equations. We will compare the use of standard arrays and static arrays from StaticArrays.jl and assess their efficiency.","category":"page"},{"location":"stratospheric_reaction/#Definition-of-the-production-destruction-system","page":"Stratospheric reaction problem","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"This stratospheric reaction problem was described by Adrian Sandu in Positive Numerical Integration Methods for Chemical Kinetic Systems, see also the paper Positivity-preserving adaptive Runge–Kutta methods by Stefan Nüßlein, Hendrik Ranocha and David I. Ketcheson. The governing equations are","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nfracdO^1Ddt = r_5 - r_6 -  r_7\nfracdOdt = 2r_1 - r_2 + r_3 - r_4 + r_6 - r_9 + r_10 - r_11\nfracdO_3dt = r_2 - r_3 - r_4 - r_5 - r_7 - r_8\nfracdO_2dt = -r_1 -r_2 + r_3 + 2r_4+r_5+2r_7+r_8+r_9\nfracdNOdt = -r_8+r_9+r_10-r_11\nfracdNO_2dt = r_8-r_9-r_10+r_11\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"with reaction rates","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nr_1 =2643 10^-10σ^3 O_2  r_2 =801810^-17O O_2   r_3 =61210^-4σ O_3\nr_4 =156710^-15O_3 O   r_5 = 107 10^-3σ^2O_3   r_6 = 71110^-11 81210^6 O^1D\nr_7 = 1210^-10O^1D O_3  r_8 = 606210^-15O_3 NO  r_9 = 106910^-11NO_2 O\nr_10 = 128910^-2σ NO_2  r_11 = 10^-8NO O\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"where","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nT = t3600 mod 24quad T_r=45quad T_s = 195\nσ(T) = begincases1  T_r T T_s0  textotherwiseendcases\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Setting mathbf u = (O^1D O O_3 O_2 NO NO_2) the initial value is mathbfu_0 = (990610^1 662410^8 532610^11 169710^16 410^6 109310^9)^T. The time domain in seconds is 43210^4 302410^5, which corresponds to 120 840 in hours. There are two independent linear invariants, e.g. u_1+u_2+3u_3+2u_4+u_5+2u_6=(113212)cdotmathbfu_0 and u_5+u_6 = 109710^9.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The stratospheric reaction problem can be represented as a (non-conservative) PDS with production terms","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\np_13 = r_5  p_21 = r_6  p_22 = r_1+r_10\np_23 = r_3  p_24 = r_1 p_32 = r_2\np_41 = r_7  p_42= r_4+r_9  p_43= r_4+r_7+r_8\np_44 = r_3+r_5  p_56=r_9+r_10  p_65=r_8+r_11\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"and additional destruction terms","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nd_22= r_11  d_44=r_2\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In addition, all production and destruction terms not listed have the value zero.","category":"page"},{"location":"stratospheric_reaction/#Solution-of-the-production-destruction-system","page":"Stratospheric reaction problem","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Now we are ready to define a PDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"As mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"an out-of-place implementation with standard (dynamic) matrices and vectors,\nan in-place implementation with standard (dynamic) matrices and vectors,\nan out-of-place implementation with static matrices and vectors from StaticArrays.jl.","category":"page"},{"location":"stratospheric_reaction/#Standard-out-of-place-implementation","page":"Stratospheric reaction problem","title":"Standard out-of-place implementation","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Here we create an out-of-place function to compute the production matrix with return type Matrix{Float64} and a second out-of-place function for the destruction vector with return type Vector{Float64}.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using PositiveIntegrators # load PDSProblem\n\nfunction prod(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    return [0.0 0.0 r5 0.0 0.0 0.0;\n            r6 r1+r10 r3 r1 0.0 0.0;\n            0.0 r2 0.0 0.0 0.0 0.0;\n            r7 r4+r9 r4+r7+r8 r3+r5 0.0 0.0;\n            0.0 0.0 0.0 0.0 0.0 r9+r10;\n            0.0 0.0 0.0 0.0 r8+r11 0.0]\nend\n\nfunction dest(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    return [0.0, r11, 0.0, r2, 0.0, 0.0]\nend\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The solution of the stratospheric reaction problem can now be computed as follows.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"u0 = [9.906e1, 6.624e8, 5.326e11, 1.697e16, 4e6, 1.093e9] # initial values\ntspan = (4.32e4, 3.024e5) # time domain\nprob_oop = PDSProblem(prod, dest, u0, tspan) # create the PDS\n\nsol_oop = solve(prob_oop, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Plotting the solution shows that the components O¹ᴰ, O and NO are in danger of becoming negative.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using Plots\n\nplot(sol_oop,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none,\n    widen = true\n    )","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"PositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"isnonnegative(sol_oop)","category":"page"},{"location":"stratospheric_reaction/#Standard-in-place-implementation","page":"Stratospheric reaction problem","title":"Standard in-place implementation","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Next we create in-place functions for the production matrix and the destruction vector.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"\nfunction prod!(P, u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    fill!(P, zero(eltype(P)))\n    P[1, 3] = r5\n    P[2, 1] = r6\n    P[2, 2] = r1 + r10\n    P[2, 3] = r3\n    P[2, 4] = r1\n    P[3, 2] = r2\n    P[4, 1] = r7\n    P[4, 2] = r4 + r9\n    P[4, 3] = r4 + r7 + r8\n    P[4, 4] = r3 + r5\n    P[5, 6] = r9 + r10\n    P[6, 5] = r8 + r11\n    return nothing\nend\n\nfunction dest!(D, u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    fill!(D, zero(eltype(D)))\n\n    D[2] = r11\n    D[4] = r2\n\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The solution of the in-place implementation of the stratospheric reaction problem can now be computed as follows.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"\nprob_ip = PDSProblem(prod!, dest!, u0, tspan) # create the PDS\nsol_ip = solve(prob_ip, MPRK43I(1.0, 0.5))\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"\nplot(sol_ip,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none,\n    widen = true\n    )","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"We also check that the in-place and out-of-place solutions are equivalent.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"sol_oop.t ≈ sol_ip.t && sol_oop.u ≈ sol_ip.u","category":"page"},{"location":"stratospheric_reaction/#Using-static-arrays","page":"Stratospheric reaction problem","title":"Using static arrays","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"For PDS with a small number of differential equations like the stratospheric reaction model the use of static arrays will be more efficient. To create a function which computes the production matrix and returns a static matrix, we only need to add the @SMatrix macro. Accordingly, we use the @SVector macro for the destruction vector.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using StaticArrays\n\nfunction prod_static(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    return @SMatrix [0.0 0.0 r5 0.0 0.0 0.0;\n            r6 r1+r10 r3 r1 0.0 0.0;\n            0.0 r2 0.0 0.0 0.0 0.0;\n            r7 r4+r9 r4+r7+r8 r3+r5 0.0 0.0;\n            0.0 0.0 0.0 0.0 0.0 r9+r10;\n            0.0 0.0 0.0 0.0 r8+r11 0.0]\nend\n\nfunction dest_static(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    return @SVector [0.0, r11, 0.0, r2, 0.0, 0.0]\nend\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In addition we also want to use a static vector to hold the initial conditions.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"u0_static = @SVector [9.906e1, 6.624e8, 5.326e11, 1.697e16, 4e6, 1.093e9] # initial values\nprob_static = PDSProblem(prod_static, dest_static, u0_static, tspan) # create the PDS\n\nsol_static = solve(prob_static, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"This solution is also nonnegative.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"isnonnegative(sol_static)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using Plots\n\nplot(sol_static,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none,\n    widen = true\n    )","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The above implementation of the stratospheric reaction problem using StaticArrays can also be found in the Example Problems as prob_pds_stratreac.","category":"page"},{"location":"stratospheric_reaction/#Preservation-of-linear-invariants","page":"Stratospheric reaction problem","title":"Preservation of linear invariants","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"As MPRK schemes do not preserve general linear invariants, especially when applied to non-conservative PDS, we compute and plot the relative errors with respect to both linear invariants to see how well these are preserved.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"linear_invariant(a, u) = sum(a .* u)\n\nfunction relerr_lininv(a, u0, sol)\n    c = linear_invariant(a, u0)\n    return abs.(c .- (x -> linear_invariant(a, x)).(sol.u))./c\nend\n\na1 = [1; 1; 3; 2; 1; 2] # first linear invariant\na2 = [0; 0; 0; 0; 1; 1] # second linear invariant\n\np1 = plot(sol_oop.t, relerr_lininv(a1, u0, sol_oop))\np2 = plot(sol_oop.t, relerr_lininv(a2, u0, sol_oop))\nplot(p1, p2,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    legend = :none)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In contrast to MPRK schemes, Runge-Kutta and Rosenbrock methods preserve all linear invariants, but are not guaranteed to generate nonnegative solutions. One way to enforce nonnegative solutions of such schemes is passing isnegative to the solver option isoutofdomain. We show this using the Rosenbrock scheme Rosenbrock23 as an example.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using OrdinaryDiffEqRosenbrock\n\nsol_tmp = solve(prob_oop, Rosenbrock23());\nisnonnegative(sol_tmp)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"sol_Ros23 = solve(prob_oop, Rosenbrock23(), isoutofdomain = isnegative);\nisnonnegative(sol_Ros23)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"p3 = plot(sol_Ros23.t, relerr_lininv(a1, u0, sol_Ros23))\np4 = plot(sol_Ros23.t, relerr_lininv(a2, u0, sol_Ros23))\nplot(p3, p4,\n     xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n     legend = :none)","category":"page"},{"location":"stratospheric_reaction/#Performance-comparison","page":"Stratospheric reaction problem","title":"Performance comparison","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Finally, we use BenchmarkTools.jl to compare the different implementations and to show the benefit of using static arrays.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using BenchmarkTools\n@benchmark solve(prob_oop, MPRK43I(1.0, 0.5))","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using BenchmarkTools\n@benchmark solve(prob_ip, MPRK43I(1.0, 0.5))","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"@benchmark solve(prob_static, MPRK43I(1.0, 0.5))","category":"page"},{"location":"stratospheric_reaction/#Package-versions","page":"Stratospheric reaction problem","title":"Package versions","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"These results were obtained using the following versions.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\", \"OrdnaryDiffEqRosenbrock\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"api_reference/#PositiveIntegrators.jl-API","page":"API reference","title":"PositiveIntegrators.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = PositiveIntegrators","category":"page"},{"location":"api_reference/#Problem-types","page":"API reference","title":"Problem types","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"ConservativePDSProblem\nPDSProblem","category":"page"},{"location":"api_reference/#PositiveIntegrators.ConservativePDSProblem","page":"API reference","title":"PositiveIntegrators.ConservativePDSProblem","text":"ConservativePDSProblem(P, u0, tspan, p = NullParameters();\n                       p_prototype = nothing,\n                       analytic = nothing,\n                       std_rhs = nothing)\n\nA structure describing a conservative system of ordinary differential equation in form of a production-destruction system (PDS). P denotes the function defining the production matrix P. The diagonal of P contains production terms without destruction counterparts. u0 is the vector of initial conditions and tspan the time span (t_initial, t_final) of the problem. The optional argument p can be used to pass additional parameters to the function P.\n\nThe function P can be given either in the out-of-place form with signature production_terms = P(u, p, t) or the in-place form P(production_terms, u, p, t).\n\nKeyword arguments:\n\np_prototype: If P is given in in-place form, p_prototype or copies thereof are used to store evaluations of P. If p_prototype is not specified explicitly and P is in-place, then p_prototype will be internally set to zeros(eltype(u0), (length(u0), length(u0))).\nanalytic: The analytic solution of a PDS must be given in the form f(u0,p,t). Specifying the analytic solution can be useful for plotting and convergence tests.\nstd_rhs: The standard ODE right-hand side evaluation function callable as du = std_rhs(u, p, t) for the out-of-place form and as std_rhs(du, u, p, t) for the in-place form. Solvers that do not rely on the production-destruction representation of the ODE, will use this function instead to compute the solution. If not specified, a default implementation calling P is used.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.PDSProblem","page":"API reference","title":"PositiveIntegrators.PDSProblem","text":"PDSProblem(P, D, u0, tspan, p = NullParameters();\n           p_prototype = nothing,\n           analytic = nothing,\n           std_rhs = nothing)\n\nA structure describing a system of ordinary differential equations in form of a production-destruction system (PDS). P denotes the function defining the production matrix P. The diagonal of P contains production terms without destruction counterparts. D is the function defining the vector of destruction terms D without production counterparts. u0 is the vector of initial conditions and tspan the time span (t_initial, t_final) of the problem. The optional argument p can be used to pass additional parameters to the functions P and D.\n\nThe functions P and D can be used either in the out-of-place form with signature production_terms = P(u, p, t) or the in-place form P(production_terms, u, p, t).\n\nKeyword arguments:\n\np_prototype: If P is given in in-place form, p_prototype or copies thereof are used to store evaluations of P. If p_prototype is not specified explicitly and P is in-place, then p_prototype will be internally set to zeros(eltype(u0), (length(u0), length(u0))).\nanalytic: The analytic solution of a PDS must be given in the form f(u0,p,t). Specifying the analytic solution can be useful for plotting and convergence tests.\nstd_rhs: The standard ODE right-hand side evaluation function callable as du = std_rhs(u, p, t) for the out-of-place form and as std_rhs(du, u, p, t) for the in-place form. Solvers that do not rely on the production-destruction representation of the ODE, will use this function instead to compute the solution. If not specified, a default implementation calling P and D is used.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Example-problems","page":"API reference","title":"Example problems","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"prob_pds_bertolazzi\nprob_pds_brusselator\nprob_pds_linmod\nprob_pds_linmod_inplace\nprob_pds_minmapk\nprob_pds_nonlinmod\nprob_pds_npzd\nprob_pds_robertson\nprob_pds_sir\nprob_pds_stratreac","category":"page"},{"location":"api_reference/#PositiveIntegrators.prob_pds_bertolazzi","page":"API reference","title":"PositiveIntegrators.prob_pds_bertolazzi","text":"prob_pds_bertolazzi\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nmathbfu=beginpmatrix2 -1 -1-1 2 -1-1 -1 2endpmatrixbeginpmatrix5u_2u_3(10^-2 + (u_2u_3)^2) + u_2u_3(10^-16 + u_2u_3(10^-8 + u_2u_3))\n10u_1u_3^2\n01(u_3 - u_2 - 25)^2u_1u_2endpmatrix\nendaligned\n\nwith initial value mathbfu_0 = (00 10 20)^T and time domain (00 10). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 30.\n\nReferences\n\nEnrico Bertolazzi. \"Positive and conservative schemes for mass action kinetics.\" Computers and Mathematics with Applications 32 (1996): 29-43. DOI: 10.1016/0898-1221(96)00142-3\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_brusselator","page":"API reference","title":"PositiveIntegrators.prob_pds_brusselator","text":"prob_pds_brusselator\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -u_1\nu_2 = -u_2u_5\nu_3 = u_2u_5\nu_4 = u_5\nu_5 = u_1 - u_2u_5 + u_5^2u_6 - u_5\nu_6 = u_2u_5 - u_5^2u_6\nendaligned\n\nwith initial value mathbfu_0 = (100 100 00 00 01 01)^T and time domain (00 200). There are two independent linear invariants, e.g. u_1+u_4+u_5+u_6 = 102 and u_2+u_3 = 100.\n\nReferences\n\nLuca Bonaventura,  and Alessandro Della Rocca. \"Unconditionally Strong Stability Preserving Extensions of the TR-BDF2 Method.\" Journal of Scientific Computing 70 (2017): 859 - 895. DOI: 10.1007/s10915-016-0267-9\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_linmod","page":"API reference","title":"PositiveIntegrators.prob_pds_linmod","text":"prob_pds_linmod\n\nPositive and conservative autonomous linear PDS\n\nbeginaligned\nu_1 = u_2 - 5u_1\nu_2 = 5u_1 - u_2\nendaligned\n\nwith initial value mathbfu_0 = (09 01)^T and time domain (00 20). There is one independent linear invariant, e.g. u_1+u_2 = 1.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_linmod_inplace","page":"API reference","title":"PositiveIntegrators.prob_pds_linmod_inplace","text":"prob_pds_linmod_inplace\n\nSame as prob_pds_linmod but with in-place computation.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_minmapk","page":"API reference","title":"PositiveIntegrators.prob_pds_minmapk","text":"prob_pds_minmapk\n\nPositive and nonconservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = k_6u_6-k_7u_1-k_1u_1u_2 +k_2u_4\nu_2 = k_5u_3-k_1u_2u_2\nu_3 = k_2u_4-k_3u_1u_3+k_4u_5-k_5u_3\nu_4 = k_1u_1u_2-k_2u_4\nu_5 = k_3u_1u_3-k_4u_5\nu_6 = k_7u_1-k_6u_6\nendaligned\n\nwith constants\n\nbeginaligned\nk_1 =frac1003  k_2 =frac13  k_3 =50\nk_4 =05  k_5 =frac103    k_6 = 01\nk_7 = 01\nendaligned\n\nThe initial value is mathbfu_0 = (01 0175 015 115 081 05)^T and the time domain (0 200). There are two independent linear invariants, e.g. u_1+u_4+u_6=175 and u_2+u_3+u_4+u_5 =2285.\n\nReferences\n\nSergio Blanes, Arieh Iserles, and Shev Macnamara. \"Positivity preserving methods for ordinary differential equations.\" ESAIM: Mathematical Modelling and Numerical Analysis 56 (2022): 1843–1870. DOI: 10.1051/m2an/2022042\nOtto Hadač, František Muzika, Vladislav Nevoral, Michal Přibyl, and Igor Schreiber \"Minimal oscillating subnetwork in the Huang-Ferrell model of the MAPK cascade.\" PLoS ONE 12 (2017): e0178457. DOI: 10.1371/journal.pone.0178457\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_nonlinmod","page":"API reference","title":"PositiveIntegrators.prob_pds_nonlinmod","text":"prob_pds_nonlinmod\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -fracu_1u_2u_1 + 10\nu_2 = fracu_1u_2u_1 + 10 - 03u_2\nu_3 = 03 u_2\nendaligned\n\nwith initial value mathbfu_0 = (998 001 001)^T and time domain (00 300). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 100.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_npzd","page":"API reference","title":"PositiveIntegrators.prob_pds_npzd","text":"prob_pds_npzd\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = 001u_2 + 001u_3 + 0003u_4 - fracu_1u_2001 + u_1\nu_2 = fracu_1u_2001 + u_1- 001u_2 - 05( 1 - e^-121u_2^2)u_3 - 005u_2\nu_3 = 05(1 - e^-121u_2^2)u_3 - 001u_3 - 002u_3\nu_4 = 005u_2 + 002u_3 - 0003u_4\nendaligned\n\nwith initial value mathbfu_0 = (80 20 10 40)^T and time domain (00 100). There is one independent linear invariant, e.g. u_1+u_2+u_3+u_4 = 150.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"Application of modified Patankar schemes to stiff biogeochemical models for the water column.\" Ocean Dynamics 55 (2005): 326-337. DOI: 10.1007/s10236-005-0001-x\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_robertson","page":"API reference","title":"PositiveIntegrators.prob_pds_robertson","text":"prob_pds_robertson\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -004u_1+10^4 u_2u_3\nu_2 =  004u_1-10^4 u_2u_3-310^7 u_2^2\nu_3 = 310^7 u_2^2\nendaligned\n\nwith initial value mathbfu_0 = (10 00 00)^T and time domain (00 10^11). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 10.\n\nReferences\n\nErnst Hairer, Gerd Wanner. \"Solving Ordinary Differential Equations II - Stiff and Differential-Algebraic Problems.\" 2nd Edition, Springer (2002): Section IV.1.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_sir","page":"API reference","title":"PositiveIntegrators.prob_pds_sir","text":"prob_pds_sir\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -2u_1u_2\nu_2 = 2u_1u_2 - u_2\nu_3 = u_2\nendaligned\n\nwith initial value mathbfu_0 = (099 0005 0005)^T and time domain (00 200). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 10.\n\nReferences\n\nRonald E. Mickens, and Talitha M. Washington. \"NSFD discretizations of interacting population models satisfying conservation laws.\" Computers and Mathematics with Applications 66 (2013): 2307-2316. DOI: 10.1016/j.camwa.2013.06.011\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_stratreac","page":"API reference","title":"PositiveIntegrators.prob_pds_stratreac","text":"prob_pds_stratreac\n\nPositive and nonconservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = r_5 - r_6 -  r_7\nu_2 = 2r_1 - r_2 + r_3 - r_4 + r_6 - r_9 + r_10 - r_11\nu_3 = r_2 - r_3 - r_4 - r_5 - r_7 - r_8\nu_4 = -r_1 -r_2 + r_3 + 2r_4+r_5+2r_7+r_8+r_9\nu_5 = -r_8+r_9+r_10-r_11\nu_6 = r_8-r_9-r_10+r_11\nendaligned\n\nwith reaction rates\n\nbeginaligned\nr_1 =2643 10^-10σ^3 u_4  r_2 =801810^-17u_2 u_4   r_3 =61210^-4σ u_3\nr_4 =156710^-15u_3 u_2   r_5 = 107 10^-3σ^2u_3   r_6 = 71110^-11 81210^6 u_1\nr_7 = 1210^-10u_1 u_3  r_8 = 606210^-15u_3 u_5  r_9 = 106910^-11u_6 u_2\nr_10 = 128910^-2σ u_6  r_11 = 10^-8u_5 u_2\nendaligned\n\nwhere\n\nbeginaligned\nT = t3600 mod 24quad T_r=45quad T_s = 195\nσ(T) = begincases1  T_r T T_s0  textotherwiseendcases\nendaligned\n\nThe initial value is mathbfu_0 = (990610^1 662410^8 532610^11 169710^16 410^6 109310^9)^T and the time domain (432 10^4 302410^5). There are two independent linear invariants, e.g. u_1+u_2+3u_3+2u_4+u_5+2u_6=(113212)cdotmathbfu_0 and u_5+u_6 = 109710^9.\n\nReferences\n\nStephan Nüsslein, Hendrik Ranocha, and David I. Ketcheson. \"Positivity-preserving adaptive Runge-Kutta methods.\" Communications in Applied Mathematics and Computer Science 16 (2021): 155-179. DOI: 10.2140/camcos.2021.16.155\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#Algorithms","page":"API reference","title":"Algorithms","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"MPE\nMPRK22\nSSPMPRK22\nMPRK43I\nMPRK43II\nSSPMPRK43\nMPDeC","category":"page"},{"location":"api_reference/#PositiveIntegrators.MPE","page":"API reference","title":"PositiveIntegrators.MPE","text":"MPE([linsolve = ..., small_constant = ...])\n\nThe first-order modified Patankar-Euler algorithm for production-destruction systems. This one-step, one-stage method is first-order accurate, unconditionally positivity-preserving, and linearly implicit.\n\nThe scheme was introduced by Burchard et al. for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension\n\nu_i^n+1 = u_i^n + Δt sum_j ji biggl(p_ij^n fracu_j^n+1u_j^n-d_ij^n fracu_i^n+1u_i^nbiggr) + Deltat p_ii^n - Δt d_ii^nfracu_i^n+1u_i^n,\n\nwhere p_ij^n = p_ij(t^nmathbf u^n) and d_ij^n = d_ij(t^nmathbf u^n).\n\nThe modified Patankar-Euler method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nThe current implementation only supports fixed time steps.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK22","page":"API reference","title":"PositiveIntegrators.MPRK22","text":"MPRK22(α; [linsolve = ..., small_constant = ...])\n\nA family of second-order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step, two-stage method which is second-order accurate, unconditionally positivity-preserving, and linearly implicit. In this implementation the stage-values are conservative as well. The parameter α is described by Kopecz and Meister (2018) and studied by Izgin, Kopecz and Meister (2022) as well as Torlo, Öffner and Ranocha (2022).\n\nThis method supports adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as first order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use a straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\nStefan Kopecz and Andreas Meister. \"On order conditions for modified Patankar-Runge-Kutta schemes.\" Applied Numerical Mathematics 123 (2018): 159-179. DOI: 10.1016/j.apnum.2017.09.004\nThomas Izgin, Stefan Kopecz, and Andreas Meister. \"On Lyapunov stability of positive and conservative time integrators and application to second order modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 56.3 (2022): 1053-1080. DOI: 10.1051/m2an/2022031\nDavide Torlo, Philipp Öffner, and Hendrik Ranocha. \"Issues with positivity-preserving Patankar-type schemes.\" Applied Numerical Mathematics 182 (2022): 117-147. DOI: 10.1016/j.apnum.2022.07.014\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.SSPMPRK22","page":"API reference","title":"PositiveIntegrators.SSPMPRK22","text":"SSPMPRK22(α, β; [linsolve = ..., small_constant = ...])\n\nA family of second-order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step, two-stage method which is second-order accurate, unconditionally positivity-preserving, and linearly implicit. The parameters α and β are described by Huang and Shu (2019) and studied by Huang, Izgin, Kopecz, Meister and Shu (2023). The difference to MPRK22 is that this method is based on the SSP formulation of an explicit second-order Runge-Kutta method. This family of schemes contains the MPRK22 family, where MPRK22(α) = SSMPRK22(0, α) applies.\n\nThis method supports adaptive time stepping, using the first order approximations (σ_i - u_i^n)  τ + u_i^n with τ=1+(α_21β_10^2)(β_20+β_21), see (2.7) in Huang and Shu (2019), to estimate the error.\n\nThe scheme was introduced by Huang and Shu for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nJuntao Huang and Chi-Wang Shu. \"Positivity-Preserving Time Discretizations for Production–Destruction Equations with Applications to Non-equilibrium Flows.\" Journal of Scientific Computing 78 (2019): 1811–1839 DOI: 10.1007/s10915-018-0852-1\nJuntao Huang, Thomas Izgin, Stefan Kopecz, Andreas Meister and Chi-Wang Shu. \"On the stability of strong-stability-preserving modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 57 (2023):1063–1086 DOI: 10.1051/m2an/2023005\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK43I","page":"API reference","title":"PositiveIntegrators.MPRK43I","text":"MPRK43I(α, β; [linsolve = ..., small_constant = ...])\n\nA family of third-order modified Patankar-Runge-Kutta schemes for production-destruction systems, which is based on the two-parameter family of third order explicit Runge–Kutta schemes. Each member of this family is an adaptive, one-step method with four-stages which is third-order accurate, unconditionally positivity-preserving, conservative and linearly implicit. In this implementation the stage-values are conservative as well. The parameters α and β must be chosen such that the Runge–Kutta coefficients are nonnegative, see Kopecz and Meister (2018) for details.\n\nThese methods support adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as second order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThese modified Patankar-Runge-Kutta methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nStefan Kopecz and Andreas Meister. \"Unconditionally positive and conservative third order modified Patankar–Runge–Kutta  discretizations of production–destruction systems.\"  BIT Numerical Mathematics 58 (2018): 691–728. DOI: 10.1007/s10543-018-0705-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK43II","page":"API reference","title":"PositiveIntegrators.MPRK43II","text":"MPRK43II(γ; [linsolve = ..., small_constant = ...])\n\nA family of third-order modified Patankar-Runge-Kutta schemes for production-destruction systems, which is based on the one-parameter family of third order explicit Runge–Kutta schemes with non-negative Runge–Kutta coefficients. Each member of this family is an adaptive, one-step method with four stages which is third-order accurate, unconditionally positivity-preserving, conservative and linearly implicit. In this implementation the stage-values are conservative as well. The parameter γ must satisfy 3/8 ≤ γ ≤ 3/4. Further details are given in Kopecz and Meister (2018).\n\nThis method supports adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as second order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThese modified Patankar-Runge-Kutta methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. To display the default value for data type type evaluate MPRK43II(gamma).small_constant_function(type), where type can be, e.g., Float64.\n\nReferences\n\nStefan Kopecz and Andreas Meister. \"Unconditionally positive and conservative third order modified Patankar–Runge–Kutta  discretizations of production–destruction systems.\"  BIT Numerical Mathematics 58 (2018): 691–728. DOI: 10.1007/s10543-018-0705-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.SSPMPRK43","page":"API reference","title":"PositiveIntegrators.SSPMPRK43","text":"SSPMPRK43([linsolve = ..., small_constant = ...])\n\nA third-order modified Patankar-Runge-Kutta algorithm for production-destruction systems. This scheme is a one-step, four-stage method which is third-order accurate, unconditionally positivity-preserving, and linearly implicit. The scheme is described by Huang, Zhao and Shu (2019) and studied by Huang, Izgin, Kopecz, Meister and Shu (2023). The difference to MPRK43I or MPRK43II is that this method is based on the SSP formulation of an explicit third-order Runge-Kutta method.\n\nThe scheme was introduced by Huang, Zhao and Shu for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. To display the default value for data type type evaluate SSPMPRK43. small_constant_function(type), where type can be, e.g., Float64.\n\nThe current implementation only supports fixed time steps.\n\nReferences\n\nJuntao Huang, Weifeng Zhao and Chi-Wang Shu. \"A Third-Order Unconditionally Positivity-Preserving Scheme for Production–Destruction Equations with Applications to Non-equilibrium Flows.\" Journal of Scientific Computing 79 (2019): 1015–1056 DOI: 10.1007/s10915-018-0881-9\nJuntao Huang, Thomas Izgin, Stefan Kopecz, Andreas Meister and Chi-Wang Shu. \"On the stability of strong-stability-preserving modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 57 (2023):1063–1086 DOI: 10.1051/m2an/2023005\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPDeC","page":"API reference","title":"PositiveIntegrators.MPDeC","text":"MPDeC(K; [nodes = :gausslobatto, linsolve = ..., small_constant = ...])\n\nA family of arbitrary order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step method which is Kth order accurate, unconditionally positivity-preserving, and linearly implicit. The integer K must be chosen to satisfy 2 ≤ K ≤ 10.  Available node choices are Lagrange or Gauss-Lobatto nodes, with the latter being the default. These methods support adaptive time stepping, using the numerical solution obtained with one correction step less as a lower-order approximation to estimate the error. The MPDeC schemes were introduced by Torlo and Öffner (2020) for autonomous conservative production-destruction systems and further investigated in Torlo, Öffner and Ranocha (2022).\n\nFor nonconservative production–destruction systems we use a straight forward extension analogous to MPE. A general discussion of DeC schemes applied to non-autonomous differential equations  and using general integration nodes is given by Ong and Spiteri (2020).\n\nThe MPDeC methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to 1e-300 in double precision computations or floatmin of the floating point type used.\n\nReferences\n\nDavide Torlo and Philipp Öffner. \"Arbitrary high-order, conservative and positivity preserving Patankar-type deferred correction schemes.\" Applied Numerical Mathematics 153 (2020): 15-34. DOI: 10.1016/j.apnum.2020.01.025\nDavide Torlo, Philipp Öffner, and Hendrik Ranocha. \"Issues with positivity-preserving Patankar-type schemes.\" Applied Numerical Mathematics 182 (2022): 117-147. DOI: 10.1016/j.apnum.2022.07.014\nBenjamin W. Ong and Raymond J. Spiteri. \"Deferred Correction Methods for Ordinary Differential Equations.\" Journal of Scientific Computing 83 (2020): Article 60. DOI: 10.1007/s10915-020-01235-8\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Auxiliary-functions","page":"API reference","title":"Auxiliary functions","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"isnegative\nisnonnegative\nrel_max_error_tend\nrel_max_error_overall\nrel_l1_error_tend\nrel_l2_error_tend\nwork_precision_adaptive\nwork_precision_adaptive!\nwork_precision_fixed\nwork_precision_fixed!","category":"page"},{"location":"api_reference/#PositiveIntegrators.isnegative","page":"API reference","title":"PositiveIntegrators.isnegative","text":"isnegative(sol::ODESolution)\n\nReturns true if sol.u contains negative elements.\n\nPlease note that negative values may occur when plotting the solution, depending on the interpolation used.\n\nSee also isnonnegative.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.isnonnegative","page":"API reference","title":"PositiveIntegrators.isnonnegative","text":"isnonnegative(u)\n\nNegation of isnegative.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_max_error_tend","page":"API reference","title":"PositiveIntegrators.rel_max_error_tend","text":"rel_max_error_tend(sol, ref_sol)\n\nReturns the relative maximum error between sol and ref_sol at time sol.t[end].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_max_error_overall","page":"API reference","title":"PositiveIntegrators.rel_max_error_overall","text":"rel_max_error_overall(sol, ref_sol)\n\nReturns the maximum of the relative maximum errors between sol and ref_sol over all time steps.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_l1_error_tend","page":"API reference","title":"PositiveIntegrators.rel_l1_error_tend","text":"rel_l1_error_tend(sol, ref_sol)\n\nReturns the relative l1 error between sol and ref_sol at time sol.t[end].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_l2_error_tend","page":"API reference","title":"PositiveIntegrators.rel_l2_error_tend","text":"rel_l2_error_tend(sol, ref_sol)\n\nReturns the relative l2 error between sol and ref_sol at time sol.t[end].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_adaptive","page":"API reference","title":"PositiveIntegrators.work_precision_adaptive","text":"work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                        adaptive_ref = false,\n                        abstol_ref = 1e-14,\n                        reltol_ref = 1e-13,\n                        compute_error = rel_max_error_tend,\n                        seconds = 2,\n                        numruns = 20,\n                        kwargs...)\n\nReturns a dictionary to create work-precision diagrams. The problem prob is solved by each algorithm in algs for all tolerances defined in abstols and reltols. For the respective tolerances the error and computing time are stored in the dictionary. If the solve is not successful for the given tolerances, then (Inf, Inf) is stored in the dictionary. The strings in the array labels are used as keys of the dictionary. The reference solution used for error computations is computed with the algorithm alg_ref. Additional keyword arguments are passed on to solve.\n\nKeyword arguments:\n\nadaptive_ref: If true the refenerce solution is computed adaptively with tolerances abstol_ref and reltol_ref. Otherwise 10^5 steps are used.\nabstol_ref: See adaptive_ref.\nreltol_ref: See adaptive_ref.\ncompute_error(sol::ODESolution, ref_sol::ODESolution): A function to compute the error between sol and ref_sol.\nseconds: If the measured computing time of a single solve is larger than seconds, then this computing time is stored in the dictionary.\nnumruns: If the measured computing time of a single solve is less than or equal to seconds, then numruns solves are performed and the median of the respective computing times is stored in the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_adaptive!","page":"API reference","title":"PositiveIntegrators.work_precision_adaptive!","text":"work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                        adaptive_ref = false,\n                        abstol_ref = 1e-14,\n                        reltol_ref = 1e-13,\n                        compute_error = rel_max_error_tend,\n                        seconds = 2,\n                        numruns = 20,\n                        kwargs...)\n\nAdds work-precision data to the dictionary dict, which was created with work_precion_fixed_adaptive. See work_precision_adaptive for the meaning of the inputs.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_fixed","page":"API reference","title":"PositiveIntegrators.work_precision_fixed","text":"work_precision_fixed(prob, algs, labels, dts, alg_ref;\n                     compute_error = rel_max_error_tend,\n                     seconds = 2,\n                     numruns = 20)\n\nReturns a dictionary to create work-precision diagrams. The problem prob is solved by each algorithm in algs for all the step sizes defined in dts. For each step size the error and computing time are stored in the dictionary. If the solve is not successful for a given step size, then (Inf, Inf) is stored in the dictionary. The strings in the array labels are used as keys of the dictionary. The reference solution used for error computations is computed with the algorithm alg_ref.\n\nKeyword arguments:\n\ncompute_error(sol::ODESolution, ref_sol::ODESolution): Function to compute the error between sol and ref_sol.\nseconds: If the measured computing time of a single solve is larger than seconds, then this computing time is stored in the dictionary.\nnumruns: If the measured computing time of a single solve is less than or equal to seconds, then numruns solves are performed and the median of the respective computing times is stored in the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_fixed!","page":"API reference","title":"PositiveIntegrators.work_precision_fixed!","text":"work_precision_fixed!(dict, prob, algs, labels, dts, alg_ref;\n                      compute_error = rel_max_error_tend,\n                      seconds = 2,\n                      numruns = 20)\n)\n\nAdds work-precision data to the dictionary dict, which was created with work_precion_fixed. See work_precision_fixed for the meaning of the inputs.\n\n\n\n\n\n","category":"function"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/NumericalMathematics/PositiveIntegrators.jl/blob/main/LICENSE\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2023-present Stefan Kopecz, Hendrik Ranocha, and contributorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"scalar_pds/#tutorial-scalar-pds","page":"Scalar equation","title":"Tutorial: Solving a scalar production-destruction equation with MPRK schemes","text":"","category":"section"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"Originally, modified Patankar-Runge-Kutta (MPRK) schemes were designed to solve positive and conservative systems of ordinary differential equations. The conservation property requires that the system consists of at least two scalar differential equations. Nevertheless, we can also apply the idea of the Patankar trick to a scalar production-destruction system (PDS)","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"u(t)=p(u(t))-d(u(t))quad u(0)=u_00","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"with nonnegative functions p and d. Since conservation is not an issue here, we can apply the Patankar trick to the destruction term d to ensure positivity and leave the production term p unweighted. A first-order scheme of this type, based on the forward Euler method, reads","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"u^n+1= u^n + Δ t p(u^n) - Δ t d(u^n)fracu^n+1u^n","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"and this idea can easily be generalized to higher-order explicit Runge-Kutta schemes.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"By closer inspection we realize that this is exactly the approach the MPRK schemes of PositiveIntegrators.jl use to solve non-conservative PDS for which the production matrix is diagonal. Hence, we can use the existing schemes to solve a scalar PDS by regarding the production term as a 11-matrix and the destruction term as a 1-vector.","category":"page"},{"location":"scalar_pds/#scalar-example-1","page":"Scalar equation","title":"Example 1","text":"","category":"section"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"We want to solve","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"u =  u^2 - uquad u(0) = 095","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"for 0 t 10. Here,  we can choose p(u)=u^2 as production term and d(u)=u as destruction term. The exact solution of this problem is","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"u(t) = frac1919+e^t","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"Next, we show how to solve this scalar PDS in the way discussed above. Please note that we must use PDSProblem to create the problem. Furthermore, we use static matrices and vectors from StaticArrays.jl instead of standard arrays for efficiency.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"using PositiveIntegrators, StaticArrays, Plots\n\nu0 = @SVector [0.95] # 1-vector\ntspan = (0.0, 10.0)\n\n# Attention: Input u is a 1-vector\nprod(u, p, t) = @SMatrix [u[1]^2] # create static 1x1-matrix\ndest(u, p, t) = @SVector [u[1]] # create static 1-vector\nprob = PDSProblem(prod, dest, u0, tspan)\n\nsol = solve(prob, MPRK22(1.0))\n\n# plot\ntt = 0:0.1:10\nf(t) = 19.0 / (19.0 + exp(t)) # exact solution\nplot(tt, f.(tt), label=\"exact\")\nplot!(sol, label=\"u\")","category":"page"},{"location":"scalar_pds/#scalar-example-2","page":"Scalar equation","title":"Example 2","text":"","category":"section"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"Next, we want to compute positive solutions of a more challenging scalar PDS. In Example 1, we could have also used standard schemes from OrdinaryDiffEq.jl and use the solver option isoutofdomain to ensure positivity. But this is not always the case as the following example will show.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"We want to compute the nonnegative solution of","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"u(t) = -sqrtlvert u(t)rvert quad u(0)=1","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"for t 0. Please note that this initial value problem has infinitely many solutions","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"u(t) = begincases frac14(t-2)^2  0 t 2 0  2 t  t^* -frac14(t-2)^2  t^*  t endcases","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"where t^* 2 is arbitrary. But among these, the only nonnegative solution is","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"u(t) = begincases frac14(t-2)^2  0 t 2 0  2 t endcases","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"This is the solution we want to compute.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"First, we try this using a standard solver from OrdinaryDiffEq.jl. We try to enforce positivity with the solver option isoutofdomain by specifying that negative solution components are not acceptable.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"using OrdinaryDiffEqRosenbrock\n\ntspan = (0.0, 3.0)\nu0 = 1.0\n\nf(u, p, t) = -sqrt(abs(u))\nprob = ODEProblem(f, u0, tspan)\n\nsol = solve(prob, Rosenbrock23(); isoutofdomain = (u, p, t) -> any(<(0), u))","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"We see that isoutofdomain cannot be used to ensure nonnegative solutions in this case, as the computation stops at about t 2 before the desired final time is reached. For at least first- and second-order explicit Runge-Kutta schemes, this can also be shown analytically. A brief computation reveals that to ensure nonnegative solutions, the time step size must tend to zero if the numerical solution tends to zero.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"Next, we want to use an MPRK scheme. We can choose p(u)=0 as the production term and d(u)=sqrtlvert urvert  as the destruction term. Furthermore, we create the PDSProblem in the same way as in Example 1.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"using PositiveIntegrators, StaticArrays, Plots\n\ntspan = (0.0, 3.0)\nu0 = @SVector [1.0]\n\nprod(u, p, t) = @SMatrix zeros(1,1)\ndest(u, p, t) = @SVector [sqrt(abs(first(u)))]\nprob = PDSProblem(prod, dest, u0, tspan)\n\nsol = solve(prob, MPRK22(1.0))\n\n# plot\ntt = 0:0.03:3\nf(t) = 0.25 * (t - 2)^2 * (t <= 2) # exact solution\nplot(tt, f.(tt), label=\"exact\")\nplot!(sol, label=\"u\")","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"We can see that the MPRK scheme used is well suited to solve the problem.","category":"page"},{"location":"scalar_pds/#Package-versions","page":"Scalar equation","title":"Package versions","text":"","category":"section"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"These results were obtained using the following versions.","category":"page"},{"location":"scalar_pds/","page":"Scalar equation","title":"Scalar equation","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"OrdinaryDiffEqRosenbrock\"],\n           mode = PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"#PositiveIntegrators.jl","page":"Home","title":"PositiveIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia library PositiveIntegrators.jl provides several time integration methods developed to preserve the positivity of numerical solutions.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PositiveIntegrators.jl is a registered Julia package. Thus, you can install it from the Julia REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"PositiveIntegrators\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to update PositiveIntegrators.jl, you can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update(\"PositiveIntegrators\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"As usual, if you want to update PositiveIntegrators.jl and all other packages in your current project, you can execute","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update()","category":"page"},{"location":"#Basic-examples","page":"Home","title":"Basic examples","text":"","category":"section"},{"location":"#Modified-Patankar-Runge-Kutta-schemes","page":"Home","title":"Modified Patankar-Runge-Kutta schemes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modified Patankar-Runge-Kutta (MPRK) schemes are unconditionally positive and conservative time integration schemes for the solution of positive and conservative ODE systems. The application of these methods is based on the representation of the ODE system as a so-called production-destruction system (PDS).","category":"page"},{"location":"#Production-destruction-systems-(PDS)","page":"Home","title":"Production-destruction systems (PDS)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The application of MPRK schemes requires the ODE system to be represented as a production-destruction system (PDS). A PDS takes the general form","category":"page"},{"location":"","page":"Home","title":"Home","text":"    u_i(t) = sum_j=1^N bigl(p_ij(tboldsymbol u) - d_ij(tboldsymbol u)bigr)quad i=1dotsN","category":"page"},{"location":"","page":"Home","title":"Home","text":"where boldsymbol u=(u_1dotsu_N)^T is the vector of unknowns and both production terms p_ij(tboldsymbol u) and destruction terms d_ij(tboldsymbol u) must be nonnegative for all ij=1dotsN. The meaning behind p_ij and d_ij is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p_ij with ine j represents the sum of all nonnegative terms which appear in equation i with a positive sign and in equation j with a negative sign.\nd_ij with ine j represents the sum of all nonnegative terms which appear in equation i with a negative sign and in equation j with a positive sign.\np_ii represents the sum of all nonnegative terms  which appear in equation i and don't have a negative counterpart in one of the other equations.\nd_ii represents the sum of all negative terms which appear in equation i and don't have a positive counterpart in one of the other equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This naming convention leads to p_ij = d_ji for i j and therefore a PDS is completely defined by the production matrix mathbfP=(p_ij)_ij=1dotsN and the destruction vector mathbfd=(d_ii)_i=1dotsN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As an example we consider the Lotka-Volterra model","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nu_1 = 2u_1-u_1u_2\nu_2 = u_1u_2-u_2\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"which always has positive solutions if positive initial values are supplied. Assuming u_1u_20, the above naming scheme results in","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\np_11(u_1u_2) = 2u_1\np_21(u_1u_2) = u_1u_2 = d_12(u_1u_2) \nd_22(u_1u_2) = u_2\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where all remaining production and destruction terms are zero. Consequently the production matrix mathbf P and destruction vector mathbf d are","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbf P(u_1u_2) = beginpmatrix2u_1  0 u_1u_2  0endpmatrixquad mathbf d(u_1u_2) = beginpmatrix0 u_2endpmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"Plots\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To solve this PDS together with initial values u_1(0)=u_2(0)=2 on the time domain (010), we first need to create a PDSProblem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PositiveIntegrators # load PDSProblem\n\nP(u, p, t) = [2*u[1]  0; u[1]*u[2]  0] # Production matrix\nd(u, p, t) = [0; u[2]] # Destruction vector\n\nu0 = [2.0; 2.0] # initial values\ntspan = (0.0, 10.0) # time span\n\n# Create PDS\nprob = PDSProblem(P, d, u0, tspan)\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that the problem has been created, we can solve it with any method of PositiveIntegrators.jl. In the following, we use the method MPRK22(1.0). In addition, we could also use any method provided by OrdinaryDiffEq.jl, but these might possibly generate negative approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sol = solve(prob, MPRK22(1.0))\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we can use Plots.jl to visualize the solution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\n\nplot(sol)","category":"page"},{"location":"#Conservative-production-destruction-systems","page":"Home","title":"Conservative production-destruction systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A PDS with the additional property","category":"page"},{"location":"","page":"Home","title":"Home","text":"  p_ii(tboldsymbol y)=d_ii(tboldsymbol y)=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"for i=1dotsN is called conservative. In this case we have p_ij=d_ji for all ij=1dotsN, which leads to","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracddtsum_i=1^N y_i=sum_i=1^N y_i = sum_mathclapij=1^N bigl(p_ij(tboldsymbol y) - d_ij(tboldsymbol y)bigr)= sum_mathclapij=1^N bigl(p_ij(tboldsymbol y) - p_ji(tboldsymbol y)bigr) = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"This shows that the sum of the state variables of a conservative PDS remains constant over time, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_i=1^N y_i(t) = sum_i=1^N y_i(0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for all times t0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One specific example of a conservative PDS is the SIR model","category":"page"},{"location":"","page":"Home","title":"Home","text":"S = -fracβ S INquad I= fracβ S IN - γ Iquad R=γ I","category":"page"},{"location":"","page":"Home","title":"Home","text":"with N=S+I+R and betagamma0. Assuming SIR0 the production and destruction terms are given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"p_21(SIR) = d_12(SIR) = fracβ S INquad p_32(SIR) = d_23(SIR) = γ I","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the remaining production and destruction terms are zero. The corresponding production matrix mathbf P is","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbf P(SIR) = beginpmatrix0  0  0 fracβ S IN  0  0 0  γ I  0endpmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following example shows how to implement the above SIR model with beta=04 gamma=004, initial conditions S(0)=997 I(0)=3 R(0)=0 and time domain (0 100) using ConservativePDSProblem from PositiveIntegrators.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PositiveIntegrators\n\n# Out-of-place implementation of the P matrix for the SIR model\nfunction P(u, p, t)\n  S, I, R = u\n\n  β = 0.4\n  γ = 0.04\n  N = 1000.0\n\n  P = zeros(3,3)\n  P[2,1] = β*S*I/N\n  P[3,2] = γ*I\n  return P\nend\n\nu0 = [997.0; 3.0; 0.0]; # initial values\ntspan = (0.0, 100.0); # time span\n\n# Create SIR problem\nprob = ConservativePDSProblem(P, u0, tspan)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the SIR model is not only conservative but also positive, we can use any scheme from PositiveIntegrators.jl to solve it. Here we use MPRK22(1.0). Please note that any method from OrdinaryDiffEq.jl can be used as well, but might possibly generate negative approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sol = solve(prob, MPRK22(1.0))\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we can use Plots.jl to visualize the solution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\n\nplot(sol, label = [\"S\" \"I\" \"R\"], legend=:right)\nplot!(sol.t, sum.(sol.u), label = \"S+I+R\") # Plot S+I+R over time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We see that there is always a nonnegative number of people in each compartment, while the population S+I+R remains constant over time.","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use PositiveIntegrators.jl for your research, please cite it using the bibtex entry","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{PositiveIntegrators.jl,\n  title={{PositiveIntegrators.jl}: {A} {J}ulia library of positivity-preserving\n         time integration methods},\n  author={Kopecz, Stefan and Lampert, Joshua and Ranocha, Hendrik},\n  year={2023},\n  doi={10.5281/zenodo.10868393},\n  url={https://github.com/NumericalMathematics/PositiveIntegrators.jl}\n}","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"page"}]
}
