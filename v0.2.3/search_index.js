var documenterSearchIndex = {"docs":
[{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/SKopecz/PositiveIntegrators.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ContributingPositiveIntegrators.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.PositiveIntegrators.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"npzd_model/#tutorial-npzd","page":"NPZD model","title":"Tutorial: Solution of an NPZD model","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"This tutorial is about the efficient solution of production-destruction systems (PDS) with a small number of differential equations. We will compare the use of standard arrays and static arrays from StaticArrays.jl and assess their efficiency.","category":"page"},{"location":"npzd_model/#Definition-of-the-production-destruction-system","page":"NPZD model","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The NPZD model we want to solve was described by Burchard, Deleersnijder and Meister in Application of modified Patankar schemes to stiff biogeochemical models for the water column. The model reads","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"beginaligned\nN = 001P + 001Z + 0003D - fracNP001 + N\nP = fracNP001 + N- 001P - 05( 1 - e^-121P^2)Z - 005P\nZ = 05(1 - e^-121P^2)Z - 001Z - 002Z\nD = 005P + 002Z - 0003D\nendaligned","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"and we consider the initial conditions N=8, P=2, Z=1 and D=4. The time domain of interest is tin010. ","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The model can be represented as a conservative PDS with production terms","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"beginaligned\np_12 = 001 P  p_13 = 001 Z  p_14 = 0003 D\np_21 = fracNP001 + N  p_32 = 05  (10 - e^-121  P^2)  Z p_42 = 005  P\np_43 = 002  Z\nendaligned","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"whereby production terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix (p_ij)_ij=1^4.","category":"page"},{"location":"npzd_model/#Solution-of-the-production-destruction-system","page":"NPZD model","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. ","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"As mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"an out-of-place implementation with standard (dynamic) matrices and vectors,\nan in-place implementation with standard (dynamic) matrices and vectors,\nan out-of-place implementation with static matrices and vectors from StaticArrays.jl.","category":"page"},{"location":"npzd_model/#Standard-out-of-place-implementation","page":"NPZD model","title":"Standard out-of-place implementation","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Here we create a function to compute the production matrix with return type Matrix{Float64}.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction prod(u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    return [0.0 p12 p13 p14;\n            p21 0.0 0.0 0.0;\n            0.0 p32 0.0 0.0;\n            0.0 p42 p43 0.0]\nend\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The solution of the NPZD model can now be computed as follows.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"u0 = [8.0, 2.0, 1.0, 4.0] # initial values\ntspan = (0.0, 10.0) # time domain\nprob_oop = ConservativePDSProblem(prod, u0, tspan) # create the PDS\n\nsol_oop = solve(prob_oop, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Plotting the solution shows that the components N and P are in danger of becoming negative. ","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using Plots\n\nplot(sol_oop; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"PositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"isnonnegative(sol_oop)","category":"page"},{"location":"npzd_model/#Standard-in-place-implementation","page":"NPZD model","title":"Standard in-place implementation","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Next we create an in-place function for the production matrix.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"\nfunction prod!(PMat, u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    fill!(PMat, zero(eltype(PMat)))\n\n    PMat[1, 2] = p12\n    PMat[1, 3] = p13\n    PMat[1, 4] = p14\n    PMat[2, 1] = p21\n    PMat[3, 2] = p32\n    PMat[4, 2] = p42\n    PMat[4, 3] = p43\n\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The solution of the in-place implementation of the NPZD model can now be computed as follows.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"\nprob_ip = ConservativePDSProblem(prod!, u0, tspan)\nsol_ip = solve(prob_ip, MPRK43I(1.0, 0.5))\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"\nplot(sol_ip; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"We also check that the in-place and out-of-place solutions are equivalent.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"sol_oop.t ≈ sol_ip.t && sol_oop.u ≈ sol_ip.u","category":"page"},{"location":"npzd_model/#Using-static-arrays","page":"NPZD model","title":"Using static arrays","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"For PDS with a small number of differential equations like the NPZD model the use of static arrays will be more efficient. To create a function which computes the production matrix and returns a static matrix, we only need to add the @SMatrix macro.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using StaticArrays\n\nfunction prod_static(u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    return @SMatrix [0.0 p12 p13 p14;\n                     p21 0.0 0.0 0.0;\n                     0.0 p32 0.0 0.0;\n                     0.0 p42 p43 0.0]\nend\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"In addition we also want to use a static vector to hold the initial conditions.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"u0_static = @SVector [8.0, 2.0, 1.0, 4.0] # initial values\nprob_static = ConservativePDSProblem(prod_static, u0_static, tspan) # create the PDS\n\nsol_static = solve(prob_static, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using Plots\n\nplot(sol_static; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"This solution is also nonnegative.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"isnonnegative(sol_static)","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"The above implementation of the NPZD model using StaticArrays can also be found in the Example Problems as prob_pds_npzd.","category":"page"},{"location":"npzd_model/#Performance-comparison","page":"NPZD model","title":"Performance comparison","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"Finally, we use BenchmarkTools.jl to show the benefit of using static arrays.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using BenchmarkTools\n@benchmark solve(prob_oop, MPRK43I(1.0, 0.5))","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using BenchmarkTools\n@benchmark solve(prob_ip, MPRK43I(1.0, 0.5))","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"@benchmark solve(prob_static, MPRK43I(1.0, 0.5))","category":"page"},{"location":"npzd_model/#Package-versions","page":"NPZD model","title":"Package versions","text":"","category":"section"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"These results were obtained using the following versions.","category":"page"},{"location":"npzd_model/","page":"NPZD model","title":"NPZD model","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\", \"OrdinaryDiffEq\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"heat_equation_dirichlet/#tutorial-heat-equation-dirichlet","page":"Heat Equation, Dirichlet BCs","title":"Tutorial: Solution of the heat equation with Dirichlet boundary conditions","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"We continue the previous tutorial on solving the heat equation with Neumann boundary conditions by looking at Dirichlet boundary conditions instead, resulting in a non-conservative production-destruction system.","category":"page"},{"location":"heat_equation_dirichlet/#Definition-of-the-(non-conservative)-production-destruction-system","page":"Heat Equation, Dirichlet BCs","title":"Definition of the (non-conservative) production-destruction system","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"Consider the heat equation","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"partial_t u(tx) = mu partial_x^2 u(tx)quad u(0x)=u_0(x)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"with μ  0, t 0, xin01, and homogeneous Dirichlet boundary conditions. We use again a finite volume discretization, i.e., we split the domain 0 1 into N uniform cells of width Delta x = 1  N. As degrees of freedom, we use the mean values of u(t) in each cell approximated by the point value u_i(t) in the center of cell i. Finally, we use the classical central finite difference discretization of the Laplacian with homogeneous Dirichlet boundary conditions, resulting in the ODE","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"partial_t u(t) = L u(t)\nquad\nL = fracmuDelta x^2 beginpmatrix\n    -2  1 \n    1  -2  1 \n     ddots  ddots  ddots \n     1  -2  1 \n     1  -2\nendpmatrix","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"The system can be written as a non-conservative PDS with production terms","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"beginaligned\np_ii-1(tmathbf u(t)) = fracmuDelta x^2 u_i-1(t)quad i=2dotsN \np_ii+1(tmathbf u(t)) = fracmuDelta x^2 u_i+1(t)quad i=1dotsN-1\nendaligned","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"and destruction terms d_ij = p_ji for i ne j as well as the non-conservative destruction terms","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"beginaligned\nd_11(tmathbf u(t)) = fracmuDelta x^2 u_1(t) \nd_NN(tmathbf u(t)) = fracmuDelta x^2 u_N(t)\nendaligned","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"In addition, all production and destruction terms not listed are zero.","category":"page"},{"location":"heat_equation_dirichlet/#Solution-of-the-non-conservative-production-destruction-system","page":"Heat Equation, Dirichlet BCs","title":"Solution of the non-conservative production-destruction system","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"Now we are ready to define a PDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use N = 100 nodes and the time domain t in 01. Moreover, we choose the initial condition","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"u_0(x) = sin(pi x)^2","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"x_boundaries = range(0, 1, length = 101)\nx = x_boundaries[1:end-1] .+ step(x_boundaries) / 2\nu0 = @. sinpi(x)^2 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"We will choose three different matrix types for the production terms and the resulting linear systems:","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"standard dense matrices (default)\nsparse matrices (from SparseArrays.jl)\ntridiagonal matrices (from LinearAlgebra.jl)","category":"page"},{"location":"heat_equation_dirichlet/#Standard-dense-matrices","page":"Heat Equation, Dirichlet BCs","title":"Standard dense matrices","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction heat_eq_P!(P, u, μ, t)\n    fill!(P, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    let i = 1\n        # Dirichlet boundary condition\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    for i in 2:(length(u) - 1)\n        # interior stencil\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    let i = length(u)\n        # Dirichlet boundary condition\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n    end\n\n    return nothing\nend\n\nfunction heat_eq_D!(D, u, μ, t)\n    fill!(D, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    # Dirichlet boundary condition\n    D[begin] = u[begin] * μ_Δx2\n    D[end] = u[end] * μ_Δx2\n\n    return nothing\nend\n\nμ = 1.0e-2\nprob = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ) # create the PDS\n\nsol = solve(prob, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"page"},{"location":"heat_equation_dirichlet/#Sparse-matrices","page":"Heat Equation, Dirichlet BCs","title":"Sparse matrices","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"To use different matrix types for the production terms and linear systems, you can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), length(u0) - 1),\n                      +1 => ones(eltype(u0), length(u0) - 1))\nprob_sparse = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ;\n                         p_prototype = p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"page"},{"location":"heat_equation_dirichlet/#Tridiagonal-matrices","page":"Heat Equation, Dirichlet BCs","title":"Tridiagonal matrices","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"The sparse matrices used in this case have a very special structure since they are in fact tridiagonal matrices. Thus, we can also use the special matrix type Tridiagonal from the standard library LinearAlgebra.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using LinearAlgebra\np_prototype = Tridiagonal(ones(eltype(u0), length(u0) - 1),\n                          ones(eltype(u0), length(u0)),\n                          ones(eltype(u0), length(u0) - 1))\nprob_tridiagonal = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ;\n                              p_prototype = p_prototype)\n\nsol_tridiagonal = solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_tridiagonal.u); label = \"u\")","category":"page"},{"location":"heat_equation_dirichlet/#Performance-comparison","page":"Heat Equation, Dirichlet BCs","title":"Performance comparison","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using BenchmarkTools\n@benchmark solve(prob, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"@benchmark solve(prob_sparse, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"By default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized  for. Thus, it is often possible to gain performance by switching to KLU  instead.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using LinearSolve\n@benchmark solve(prob_sparse, MPRK22(1.0; linsolve = KLUFactorization()); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"@benchmark solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_dirichlet/#Package-versions","page":"Heat Equation, Dirichlet BCs","title":"Package versions","text":"","category":"section"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"These results were obtained using the following versions.","category":"page"},{"location":"heat_equation_dirichlet/","page":"Heat Equation, Dirichlet BCs","title":"Heat Equation, Dirichlet BCs","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\", \"OrdinaryDiffEq\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"robertson/#tutorial-robertson","page":"Robertson problem","title":"Tutorial: Solution of Robertson problem","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"In this tutorial we show that MPRK schemes can be used to integrate stiff problems.  We also show how callbacks can be used to change the time step in non-adaptive schemes.","category":"page"},{"location":"robertson/#Definition-of-the-production-destruction-system","page":"Robertson problem","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The well known Robertson problem is given by","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"beginaligned\nu_1 = -004u_1+10^4 u_2u_3  u_1(0)=1\nu_2 =  004u_1-10^4 u_2u_3-310^7 u_2^2  u_2(0)=0 \nu_3 = 310^7 u_2^2  u_3(0)=0\nendaligned","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The time domain of interest is tin010^11, because of which some kind of adaptive time stepping is required. ","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The model can be represented as a conservative PDS with production terms","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"beginaligned\np_12(tmathbfu) = 10^4u_2u_3\np_21(tmathbfu) = 004u_1 \np_32(tmathbfu) = 310^7u_2^2\nendaligned","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"whereby production terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix mathbf P=(p_ij).","category":"page"},{"location":"robertson/#Solution-of-the-production-destruction-system","page":"Robertson problem","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with any method of PositiveIntegrators.jl or OrdinaryDiffEq.jl which is suited for stiff problems.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"Since this PDS consists of only three differential equations we provide an out-of-place implementation for the production matrix. Furthermore, we use static arrays from StaticArrays.jl for additional efficiency. See also the tutorials on the solution of an NPZD model or an stratospheric reaction problem.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using PositiveIntegrators, StaticArrays\n\nfunction prod(u, p, t)\n    @SMatrix [0.0 1e4*u[2]*u[3] 0.0; \n              4e-2*u[1] 0.0 0.0; \n              0.0 3e7*u[2]^2 0.0]\nend\nu0 = @SVector [1.0, 0.0, 0.0]\ntspan = (0.0, 1.0e11)\nprob = ConservativePDSProblem(prod, u0, tspan)\n\nsol = solve(prob, MPRK43I(1.0, 0.5))\nnothing #hide","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using Plots\n\nplot(sol, tspan = (1e-6, 1e11),  xaxis = :log,\n     idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n     label = [\"u₁\" \"10⁴u₂\" \"u₃\"])","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"PositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"isnonnegative(sol)","category":"page"},{"location":"robertson/#Using-callbacks-to-solve-the-Robertson-problem-with-non-adatpive-schemes","page":"Robertson problem","title":"Using callbacks to solve the Robertson problem with non-adatpive schemes","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"The SSPMPRK43() scheme is only available with fixed time stepping. With a scheme like this, it would take a huge amount of time to solve the Robertson problem, since the time step must be chosen very small to accurately solve the problem in its initial phase. However, the use of a callback allows us to modify the time step size after each step, which makes a solution with a fixed step method possible. ","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"In the following example the callback increases the time step size by a factor of 1.5 after each time step.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using OrdinaryDiffEq\n\nstepsize_callback = DiscreteCallback(\n    Returns(true), # adapt the step size after every time step\n    integrator -> set_proposed_dt!(integrator, 1.5 * get_proposed_dt(integrator));\n    save_positions = (false, false),\n    initialize = (c, u, t, integrator) -> set_proposed_dt!(integrator, 1.0e-5))\nsol_cb = solve(prob, SSPMPRK43(); dt = Inf, callback =  stepsize_callback);\nnothing #hide","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"plot(sol_cb, tspan = (1e-6, 1e11),  xaxis = :log,\n     idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n     label = [\"u₁\" \"10⁴u₂\" \"u₃\"])","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"This solution is also nonnegative.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"isnonnegative(sol_cb)","category":"page"},{"location":"robertson/#Package-versions","page":"Robertson problem","title":"Package versions","text":"","category":"section"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"These results were obtained using the following versions.","category":"page"},{"location":"robertson/","page":"Robertson problem","title":"Robertson problem","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\", \"OrdinaryDiffEq\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"faq/#Troubleshooting-and-frequently-asked-questions","page":"Troubleshooting, FAQ","title":"Troubleshooting and frequently asked questions","text":"","category":"section"},{"location":"faq/#Sparse-matrices","page":"Troubleshooting, FAQ","title":"Sparse matrices","text":"","category":"section"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"You can use sparse matrices for the linear systems arising in PositiveIntegrators.jl, as described, e.g., in the tutorial on linear advection. However, you need to make sure that you do not change the sparsity pattern of the production term matrix since we assume that the structural nonzeros are kept fixed. This is a known issue. For example, you should avoid something like","category":"page"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"using SparseArrays\np = spdiagm(0 => ones(4), 1 => zeros(3))\np .= 2 * p","category":"page"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"Instead, you should be able to use a pattern like the following, where the function nonzeros is used to modify the values of a sparse matrix.","category":"page"},{"location":"faq/","page":"Troubleshooting, FAQ","title":"Troubleshooting, FAQ","text":"using SparseArrays\np = spdiagm(0 => ones(4), 1 => zeros(3))\nfor j in axes(p, 2)\n    for idx in nzrange(p, j)\n        i = rowvals(p)[idx]\n        nonzeros(p)[idx] = 10 * i + j # value p[i, j]\n    end\nend; p","category":"page"},{"location":"heat_equation_neumann/#tutorial-heat-equation-neumann","page":"Heat Equation, Neumann BCs","title":"Tutorial: Solution of the heat equation with Neumann boundary conditions","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Similar to the tutorial on linear advection, we will demonstrate how to solve a conservative production-destruction system (PDS) resulting from a PDE discretization and means to improve the performance.","category":"page"},{"location":"heat_equation_neumann/#Definition-of-the-conservative-production-destruction-system","page":"Heat Equation, Neumann BCs","title":"Definition of the conservative production-destruction system","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Consider the heat equation","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"partial_t u(tx) = mu partial_x^2 u(tx)quad u(0x)=u_0(x)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"with μ  0, t 0, xin01, and homogeneous Neumann boundary conditions. We use a finite volume discretization, i.e., we split the domain 0 1 into N uniform cells of width Delta x = 1  N. As degrees of freedom, we use the mean values of u(t) in each cell approximated by the point value u_i(t) in the center of cell i. Finally, we use the classical central finite difference discretization of the Laplacian with homogeneous Neumann boundary conditions, resulting in the ODE","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"partial_t u(t) = L u(t)\nquad\nL = fracmuDelta x^2 beginpmatrix\n    -1  1 \n    1  -2  1 \n     ddots  ddots  ddots \n     1  -2  1 \n     1  -1\nendpmatrix","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"The system can be written as a conservative PDS with production terms","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"beginaligned\np_ii-1(tmathbf u(t)) = fracmuDelta x^2 u_i-1(t)quad i=2dotsN \np_ii+1(tmathbf u(t)) = fracmuDelta x^2 u_i+1(t)quad i=1dotsN-1\nendaligned","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"and destruction terms d_ij = p_ji. In addition, all production and destruction terms not listed are zero.","category":"page"},{"location":"heat_equation_neumann/#Solution-of-the-conservative-production-destruction-system","page":"Heat Equation, Neumann BCs","title":"Solution of the conservative production-destruction system","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use N = 100 nodes and the time domain t in 01. Moreover, we choose the initial condition","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"u_0(x) = cos(pi x)^2","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"x_boundaries = range(0, 1, length = 101)\nx = x_boundaries[1:end-1] .+ step(x_boundaries) / 2\nu0 = @. cospi(x)^2 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"We will choose three different matrix types for the production terms and the resulting linear systems:","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"standard dense matrices (default)\nsparse matrices (from SparseArrays.jl)\ntridiagonal matrices (from LinearAlgebra.jl)","category":"page"},{"location":"heat_equation_neumann/#Standard-dense-matrices","page":"Heat Equation, Neumann BCs","title":"Standard dense matrices","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction heat_eq_P!(P, u, μ, t)\n    fill!(P, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    let i = 1\n        # Neumann boundary condition\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    for i in 2:(length(u) - 1)\n        # interior stencil\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    let i = length(u)\n        # Neumann boundary condition\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n    end\n\n    return nothing\nend\n\nμ = 1.0e-2\nprob = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ) # create the PDS\n\nsol = solve(prob, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"page"},{"location":"heat_equation_neumann/#Sparse-matrices","page":"Heat Equation, Neumann BCs","title":"Sparse matrices","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"To use different matrix types for the production terms and linear systems, you can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), length(u0) - 1),\n                      +1 => ones(eltype(u0), length(u0) - 1))\nprob_sparse = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ;\n                                     p_prototype = p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"page"},{"location":"heat_equation_neumann/#Tridiagonal-matrices","page":"Heat Equation, Neumann BCs","title":"Tridiagonal matrices","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"The sparse matrices used in this case have a very special structure since they are in fact tridiagonal matrices. Thus, we can also use the special matrix type Tridiagonal from the standard library LinearAlgebra.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using LinearAlgebra\np_prototype = Tridiagonal(ones(eltype(u0), length(u0) - 1),\n                          ones(eltype(u0), length(u0)),\n                          ones(eltype(u0), length(u0) - 1))\nprob_tridiagonal = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ;\n                                          p_prototype = p_prototype)\n\nsol_tridiagonal = solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"plot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_tridiagonal.u); label = \"u\")","category":"page"},{"location":"heat_equation_neumann/#Performance-comparison","page":"Heat Equation, Neumann BCs","title":"Performance comparison","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using BenchmarkTools\n@benchmark solve(prob, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"@benchmark solve(prob_sparse, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"By default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized  for. Thus, it is often possible to gain performance by switching to KLU  instead.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using LinearSolve\n@benchmark solve(prob_sparse, MPRK22(1.0; linsolve = KLUFactorization()); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"@benchmark solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)","category":"page"},{"location":"heat_equation_neumann/#Package-versions","page":"Heat Equation, Neumann BCs","title":"Package versions","text":"","category":"section"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"These results were obtained using the following versions.","category":"page"},{"location":"heat_equation_neumann/","page":"Heat Equation, Neumann BCs","title":"Heat Equation, Neumann BCs","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\", \"OrdinaryDiffEq\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"code_of_conduct/","page":"Code of conduct","title":"Code of conduct","text":"EditURL = \"https://github.com/SKopecz/PositiveIntegrators.jl/blob/main/CODE_OF_CONDUCT.md\"","category":"page"},{"location":"code_of_conduct/#code-of-conduct","page":"Code of conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of conduct","title":"Code of conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Stefan Kopecz or Hendrik Ranocha. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"linear_advection/#tutorial-linear-advection","page":"Linear Advection","title":"Tutorial: Solution of the linear advection equation","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"This tutorial is about the efficient solution of production-destruction systems (PDS) with a large number of differential equations. We will explore several ways to represent such large systems and assess their efficiency.","category":"page"},{"location":"linear_advection/#Definition-of-the-production-destruction-system","page":"Linear Advection","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"One example of the occurrence of a PDS with a large number of equations is the space discretization of a partial differential equation. In this tutorial we want to solve the linear advection equation","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"partial_t u(tx)=-apartial_x u(tx)quad u(0x)=u_0(x)","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"with a0, t 0, xin01 and periodic boundary conditions. To keep things as simple as possible, we discretize the space domain as 0=x_0x_1dots x_N-1x_N=1 with x_i = i Δ x for i=0dotsN and Δx=1N. An upwind discretization of the spatial derivative yields the ODE system","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"beginaligned\npartial_t u_1(t) =-fracaΔxbigl(u_1(t)-u_N(t)bigr)\npartial_t u_i(t) =-fracaΔxbigl(u_i(t)-u_i-1(t)bigr)quad i=2dotsN\nendaligned","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"where u_i(t) is an approximation of u(tx_i) for i=1dots N. This system can also be written as partial_t mathbf u(t)=mathbf Amathbf u(t) with mathbf u(t)=(u_1(t)dotsu_N(t)) and","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"mathbf A= fracaΔ xbeginbmatrix-10dots011-1ddots00ddotsddotsddotsvdots vdotsddotsddotsddots00dots01-1endbmatrix","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"In particular the matrix mathbf A shows that there is a single production term and a single destruction term per equation. Furthermore, the system is conservative as mathbf A has column sum zero. To be precise, the production matrix mathbf P = (p_ij) of this conservative PDS is given by","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"beginaligned\np_1N(tmathbf u(t)) = fracaΔ xu_N(t)\np_ii-1(tmathbf u(t)) = fracaΔ xu_i-1(t)quad i=2dotsN\nendaligned","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"In addition, all production and destruction terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix mathbf P.","category":"page"},{"location":"linear_advection/#Solution-of-the-production-destruction-system","page":"Linear Advection","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use a=1, N=1000 and the time domain tin01. Moreover, we choose the step function","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"u_0(x)=begincases1  04  x  06 0 textelsewhereendcases","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"as initial condition. Due to the periodic boundary conditions and the transport velocity a=1, the solution at time t=1 is identical to the initial distribution, i.e. u(1x) = u_0(x).","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"N = 1000 # number of subintervals\ndx = 1/N # mesh width\nx = LinRange(dx, 1.0, N) # discretization points x_1,...,x_N = x_0\nu0 = @. 0.0 + (0.4 ≤ x ≤ 0.6) * 1.0 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"As mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"an in-place implementation with a dense matrix,\nan in-place implementation with a sparse matrix.","category":"page"},{"location":"linear_advection/#Standard-in-place-implementation","page":"Linear Advection","title":"Standard in-place implementation","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"By default, we will use dense matrices to store the production terms and to setup/solve the linear systems arising in MPRK methods. Of course, this is not efficient for large and sparse systems like in this case.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction lin_adv_P!(P, u, p, t)\n    fill!(P, 0.0)\n    N = length(u)\n    dx = 1 / N\n    P[1, N] = u[N] / dx\n    for i in 2:N\n        P[i, i - 1] = u[i - 1] / dx\n    end\n    return nothing\nend\n\nprob = ConservativePDSProblem(lin_adv_P!, u0, tspan) # create the PDS\n\nsol = solve(prob, MPRK43I(1.0, 0.5); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"We can use isnonnegative to check that the computed solution is nonnegative,  as expected from an MPRK scheme.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"isnonnegative(sol)","category":"page"},{"location":"linear_advection/#Using-sparse-matrices","page":"Linear Advection","title":"Using sparse matrices","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"To use different matrix types for the production terms and linear systems, we can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), N - 1),\n                      N - 1 => ones(eltype(u0), 1))\nprob_sparse = ConservativePDSProblem(lin_adv_P!, u0, tspan; p_prototype=p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK43I(1.0, 0.5); save_everystep = false)\n\nnothing #hide","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"plot(x,u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"Also this solution is nonnegative.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"isnonnegative(sol_sparse)","category":"page"},{"location":"linear_advection/#Performance-comparison","page":"Linear Advection","title":"Performance comparison","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using BenchmarkTools\n@benchmark solve(prob, MPRK43I(1.0, 0.5); save_everystep = false)","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"@benchmark solve(prob_sparse, MPRK43I(1.0, 0.5); save_everystep = false)","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"By default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized for. Thus, it is often possible to gain performance by switching to KLU instead.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using LinearSolve\n@benchmark solve(prob_sparse, MPRK43I(1.0, 0.5; linsolve = KLUFactorization()); save_everystep = false)","category":"page"},{"location":"linear_advection/#Package-versions","page":"Linear Advection","title":"Package versions","text":"","category":"section"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"These results were obtained using the following versions.","category":"page"},{"location":"linear_advection/","page":"Linear Advection","title":"Linear Advection","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\", \"OrdinaryDiffEq\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"stratospheric_reaction/#tutorial-stratos","page":"Stratospheric reaction problem","title":"Tutorial: Solution of a stratospheric reaction problem","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"This tutorial is about the efficient solution of a stiff non-autonomous and non-conservative production-destruction systems (PDS) with a small number of differential equations.  We will compare the use of standard arrays and static arrays from StaticArrays.jl and assess their efficiency.","category":"page"},{"location":"stratospheric_reaction/#Definition-of-the-production-destruction-system","page":"Stratospheric reaction problem","title":"Definition of the production-destruction system","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"This stratospheric reaction problem was described by Adrian Sandu in Positive Numerical Integration Methods for Chemical Kinetic Systems, see also the paper Positivity-preserving adaptive Runge–Kutta methods by Stefan Nüßlein, Hendrik Ranocha and David I. Ketcheson. The governing equations are","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nfracdO^1Ddt = r_5 - r_6 -  r_7\nfracdOdt = 2r_1 - r_2 + r_3 - r_4 + r_6 - r_9 + r_10 - r_11\nfracdO_3dt = r_2 - r_3 - r_4 - r_5 - r_7 - r_8\nfracdO_2dt = -r_1 -r_2 + r_3 + 2r_4+r_5+2r_7+r_8+r_9\nfracdNOdt = -r_8+r_9+r_10-r_11\nfracdNO_2dt = r_8-r_9-r_10+r_11\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"with reaction rates","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nr_1 =2643 10^-10σ^3 O_2  r_2 =801810^-17O O_2   r_3 =61210^-4σ O_3\nr_4 =156710^-15O_3 O   r_5 = 107 10^-3σ^2O_3   r_6 = 71110^-11 81210^6 O^1D\nr_7 = 1210^-10O^1D O_3  r_8 = 606210^-15O_3 NO  r_9 = 106910^-11NO_2 O\nr_10 = 128910^-2σ NO_2  r_11 = 10^-8NO O\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"where","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nT = t3600 mod 24quad T_r=45quad T_s = 195\nσ(T) = begincases1  T_r T T_s0  textotherwiseendcases\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Setting mathbf u = (O^1D O O_3 O_2 NO NO_2) the initial value is mathbfu_0 = (990610^1 662410^8 532610^11 169710^16 410^6 109310^9)^T. The time domain in seconds is 43210^4 302410^5, which corresponds to 120 840 in hours. There are two independent linear invariants, e.g. u_1+u_2+3u_3+2u_4+u_5+2u_6=(113212)cdotmathbfu_0 and u_5+u_6 = 109710^9.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The stratospheric reaction problem can be represented as a (non-conservative) PDS with production terms","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\np_13 = r_5  p_21 = r_6  p_22 = r_1+r_10\np_23 = r_3  p_24 = r_1 p_32 = r_2\np_41 = r_7  p_42= r_4+r_9  p_43= r_4+r_7+r_8\np_44 = r_3+r_5  p_56=r_9+r_10  p_65=r_8+r_11\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"and additional destruction terms","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"beginaligned\nd_22= r_11  d_44=r_2\nendaligned","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In addition, all production and destruction terms not listed have the value zero.","category":"page"},{"location":"stratospheric_reaction/#Solution-of-the-production-destruction-system","page":"Stratospheric reaction problem","title":"Solution of the production-destruction system","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Now we are ready to define a PDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. ","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"As mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"an out-of-place implementation with standard (dynamic) matrices and vectors,\nan in-place implementation with standard (dynamic) matrices and vectors,\nan out-of-place implementation with static matrices and vectors from StaticArrays.jl.","category":"page"},{"location":"stratospheric_reaction/#Standard-out-of-place-implementation","page":"Stratospheric reaction problem","title":"Standard out-of-place implementation","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Here we create an out-of-place function to compute the production matrix with return type Matrix{Float64} and a second out-of-place function for the destruction vector with return type Vector{Float64}.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using PositiveIntegrators # load PDSProblem\n\nfunction prod(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    return [0.0 0.0 r5 0.0 0.0 0.0;\n            r6 r1+r10 r3 r1 0.0 0.0;\n            0.0 r2 0.0 0.0 0.0 0.0;\n            r7 r4+r9 r4+r7+r8 r3+r5 0.0 0.0;\n            0.0 0.0 0.0 0.0 0.0 r9+r10;\n            0.0 0.0 0.0 0.0 r8+r11 0.0]\nend\n\nfunction dest(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    return [0.0, r11, 0.0, r2, 0.0, 0.0]\nend\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The solution of the stratospheric reaction problem can now be computed as follows.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"u0 = [9.906e1, 6.624e8, 5.326e11, 1.697e16, 4e6, 1.093e9] # initial values\ntspan = (4.32e4, 3.024e5) # time domain\nprob_oop = PDSProblem(prod, dest, u0, tspan) # create the PDS\n\nsol_oop = solve(prob_oop, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Plotting the solution shows that the components O¹ᴰ, O and NO are in danger of becoming negative. ","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using Plots\n\nplot(sol_oop,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none, \n    widen = true\n    )","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"PositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"isnonnegative(sol_oop)","category":"page"},{"location":"stratospheric_reaction/#Standard-in-place-implementation","page":"Stratospheric reaction problem","title":"Standard in-place implementation","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Next we create in-place functions for the production matrix and the destruction vector.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"\nfunction prod!(P, u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    fill!(P, zero(eltype(P)))\n    P[1, 3] = r5\n    P[2, 1] = r6\n    P[2, 2] = r1 + r10\n    P[2, 3] = r3\n    P[2, 4] = r1\n    P[3, 2] = r2\n    P[4, 1] = r7\n    P[4, 2] = r4 + r9\n    P[4, 3] = r4 + r7 + r8\n    P[4, 4] = r3 + r5\n    P[5, 6] = r9 + r10\n    P[6, 5] = r8 + r11\n    return nothing\nend\n\nfunction dest!(D, u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    fill!(D, zero(eltype(D)))\n\n    D[2] = r11\n    D[4] = r2\n\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The solution of the in-place implementation of the stratospheric reaction problem can now be computed as follows.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"\nprob_ip = PDSProblem(prod!, dest!, u0, tspan) # create the PDS\nsol_ip = solve(prob_ip, MPRK43I(1.0, 0.5))\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"\nplot(sol_ip,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none, \n    widen = true\n    )","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"We also check that the in-place and out-of-place solutions are equivalent.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"sol_oop.t ≈ sol_ip.t && sol_oop.u ≈ sol_ip.u","category":"page"},{"location":"stratospheric_reaction/#Using-static-arrays","page":"Stratospheric reaction problem","title":"Using static arrays","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"For PDS with a small number of differential equations like the stratospheric reaction model the use of static arrays will be more efficient. To create a function which computes the production matrix and returns a static matrix, we only need to add the @SMatrix macro. Accordingly, we use the @SVector macro for the destruction vector. ","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using StaticArrays\n\nfunction prod_static(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    return @SMatrix [0.0 0.0 r5 0.0 0.0 0.0;\n            r6 r1+r10 r3 r1 0.0 0.0;\n            0.0 r2 0.0 0.0 0.0 0.0;\n            r7 r4+r9 r4+r7+r8 r3+r5 0.0 0.0;\n            0.0 0.0 0.0 0.0 0.0 r9+r10;\n            0.0 0.0 0.0 0.0 r8+r11 0.0]\nend\n\nfunction dest_static(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    return @SVector [0.0, r11, 0.0, r2, 0.0, 0.0]\nend\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In addition we also want to use a static vector to hold the initial conditions.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"u0_static = @SVector [9.906e1, 6.624e8, 5.326e11, 1.697e16, 4e6, 1.093e9] # initial values\nprob_static = PDSProblem(prod_static, dest_static, u0_static, tspan) # create the PDS\n\nsol_static = solve(prob_static, MPRK43I(1.0, 0.5))\n\nnothing #hide","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"This solution is also nonnegative.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"isnonnegative(sol_static)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using Plots\n\nplot(sol_static,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none, \n    widen = true\n    )","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"The above implementation of the stratospheric reaction problem using StaticArrays can also be found in the Example Problems as prob_pds_stratreac.","category":"page"},{"location":"stratospheric_reaction/#Preservation-of-linear-invariants","page":"Stratospheric reaction problem","title":"Preservation of linear invariants","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"As MPRK schemes do not preserve general linear invariants, especially when applied to non-conservative PDS, we compute and plot the relative errors with respect to both linear invariants to see how well these are preserved.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"linear_invariant(a, u) = sum(a .* u)\n\nfunction relerr_lininv(a, u0, sol)\n    c = linear_invariant(a, u0)\n    return abs.(c .- (x -> linear_invariant(a, x)).(sol.u))./c\nend\n\na1 = [1; 1; 3; 2; 1; 2] # first linear invariant\na2 = [0; 0; 0; 0; 1; 1] # second linear invariant\n\np1 = plot(sol_oop.t, relerr_lininv(a1, u0, sol_oop))\np2 = plot(sol_oop.t, relerr_lininv(a2, u0, sol_oop))\nplot(p1, p2, \n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    legend = :none)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"In contrast to MPRK schemes, Runge-Kutta and Rosenbrock methods preserve all linear invariants, but are not guaranteed to generate nonnegative solutions. One way to enforce nonnegative solutions of such schemes is passing isnegative to the solver option isoutofdomain. We show this using the Rosenbrock scheme Rosenbrock23 as an example.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using OrdinaryDiffEq\n\nsol_tmp = solve(prob_oop, Rosenbrock23());\nisnonnegative(sol_tmp)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"sol_Ros23 = solve(prob_oop, Rosenbrock23(), isoutofdomain = isnegative);\nisnonnegative(sol_Ros23)","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"p3 = plot(sol_Ros23.t, relerr_lininv(a1, u0, sol_Ros23))\np4 = plot(sol_Ros23.t, relerr_lininv(a2, u0, sol_Ros23))\nplot(p3, p4,\n     xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n     legend = :none)","category":"page"},{"location":"stratospheric_reaction/#Performance-comparison","page":"Stratospheric reaction problem","title":"Performance comparison","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"Finally, we use BenchmarkTools.jl to compare the different implementations and to show the benefit of using static arrays.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using BenchmarkTools\n@benchmark solve(prob_oop, MPRK43I(1.0, 0.5))","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using BenchmarkTools\n@benchmark solve(prob_ip, MPRK43I(1.0, 0.5))","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"@benchmark solve(prob_static, MPRK43I(1.0, 0.5))","category":"page"},{"location":"stratospheric_reaction/#Package-versions","page":"Stratospheric reaction problem","title":"Package versions","text":"","category":"section"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"These results were obtained using the following versions.","category":"page"},{"location":"stratospheric_reaction/","page":"Stratospheric reaction problem","title":"Stratospheric reaction problem","text":"using InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\", \"OrdinaryDiffEq\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"api_reference/#PositiveIntegrators.jl-API","page":"API reference","title":"PositiveIntegrators.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = PositiveIntegrators","category":"page"},{"location":"api_reference/#Problem-types","page":"API reference","title":"Problem types","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"ConservativePDSProblem\nPDSProblem","category":"page"},{"location":"api_reference/#PositiveIntegrators.ConservativePDSProblem","page":"API reference","title":"PositiveIntegrators.ConservativePDSProblem","text":"ConservativePDSProblem(P, u0, tspan, p = NullParameters();\n                       p_prototype = nothing,\n                       analytic = nothing,\n                       std_rhs = nothing)\n\nA structure describing a conservative system of ordinary differential equation in form of a production-destruction system (PDS). P denotes the function defining the production matrix P. The diagonal of P contains production terms without destruction counterparts. u0 is the vector of initial conditions and tspan the time span (t_initial, t_final) of the problem. The optional argument p can be used to pass additional parameters to the function P.\n\nThe function P can be given either in the out-of-place form with signature production_terms = P(u, p, t) or the in-place form P(production_terms, u, p, t).\n\nKeyword arguments:\n\np_prototype: If P is given in in-place form, p_prototype or copies thereof are used to store evaluations of P. If p_prototype is not specified explicitly and P is in-place, then p_prototype will be internally set to zeros(eltype(u0), (length(u0), length(u0))).\nanalytic: The analytic solution of a PDS must be given in the form f(u0,p,t). Specifying the analytic solution can be useful for plotting and convergence tests.\nstd_rhs: The standard ODE right-hand side evaluation function callable as du = std_rhs(u, p, t) for the out-of-place form and as std_rhs(du, u, p, t) for the in-place form. Solvers that do not rely on the production-destruction representation of the ODE, will use this function instead to compute the solution. If not specified, a default implementation calling P is used.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.PDSProblem","page":"API reference","title":"PositiveIntegrators.PDSProblem","text":"PDSProblem(P, D, u0, tspan, p = NullParameters();\n           p_prototype = nothing,\n           analytic = nothing,\n           std_rhs = nothing)\n\nA structure describing a system of ordinary differential equations in form of a production-destruction system (PDS). P denotes the function defining the production matrix P. The diagonal of P contains production terms without destruction counterparts. D is the function defining the vector of destruction terms D without production counterparts. u0 is the vector of initial conditions and tspan the time span (t_initial, t_final) of the problem. The optional argument p can be used to pass additional parameters to the functions P and D.\n\nThe functions P and D can be used either in the out-of-place form with signature production_terms = P(u, p, t) or the in-place form P(production_terms, u, p, t).\n\nKeyword arguments:\n\np_prototype: If P is given in in-place form, p_prototype or copies thereof are used to store evaluations of P. If p_prototype is not specified explicitly and P is in-place, then p_prototype will be internally set to zeros(eltype(u0), (length(u0), length(u0))).\nanalytic: The analytic solution of a PDS must be given in the form f(u0,p,t). Specifying the analytic solution can be useful for plotting and convergence tests.\nstd_rhs: The standard ODE right-hand side evaluation function callable as du = std_rhs(u, p, t) for the out-of-place form and as std_rhs(du, u, p, t) for the in-place form. Solvers that do not rely on the production-destruction representation of the ODE, will use this function instead to compute the solution. If not specified, a default implementation calling P and D is used.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Example-problems","page":"API reference","title":"Example problems","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"prob_pds_bertolazzi\nprob_pds_brusselator\nprob_pds_linmod\nprob_pds_linmod_inplace\nprob_pds_nonlinmod\nprob_pds_npzd\nprob_pds_robertson\nprob_pds_sir\nprob_pds_stratreac","category":"page"},{"location":"api_reference/#PositiveIntegrators.prob_pds_bertolazzi","page":"API reference","title":"PositiveIntegrators.prob_pds_bertolazzi","text":"prob_pds_bertolazzi\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nmathbfu=beginpmatrix2 -1 -1-1 2 -1-1 -1 2endpmatrixbeginpmatrix5u_2u_3(10^-2 + (u_2u_3)^2) + u_2u_3(10^-16 + u_2u_3(10^-8 + u_2u_3))\n10u_1u_3^2\n01(u_3 - u_2 - 25)^2u_1u_2endpmatrix\nendaligned\n\nwith initial value mathbfu_0 = (00 10 20)^T and time domain (00 10). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 30.\n\nReferences\n\nEnrico Bertolazzi. \"Positive and conservative schemes for mass action kinetics.\" Computers and Mathematics with Applications 32 (1996): 29-43. DOI: 10.1016/0898-1221(96)00142-3\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_brusselator","page":"API reference","title":"PositiveIntegrators.prob_pds_brusselator","text":"prob_pds_brusselator\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -u_1\nu_2 = -u_2u_5\nu_3 = u_2u_5\nu_4 = u_5\nu_5 = u_1 - u_2u_5 + u_5^2u_6 - u_5\nu_6 = u_2u_5 - u_5^2u_6\nendaligned\n\nwith initial value mathbfu_0 = (100 100 00 00 01 01)^T and time domain (00 200). There are two independent linear invariants, e.g. u_1+u_4+u_5+u_6 = 102 and u_2+u_3 = 100.\n\nReferences\n\nLuca Bonaventura,  and Alessandro Della Rocca. \"Unconditionally Strong Stability Preserving Extensions of the TR-BDF2 Method.\" Journal of Scientific Computing 70 (2017): 859 - 895. DOI: 10.1007/s10915-016-0267-9\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_linmod","page":"API reference","title":"PositiveIntegrators.prob_pds_linmod","text":"prob_pds_linmod\n\nPositive and conservative autonomous linear PDS\n\nbeginaligned\nu_1 = u_2 - 5u_1\nu_2 = 5u_1 - u_2\nendaligned\n\nwith initial value mathbfu_0 = (09 01)^T and time domain (00 20). There is one independent linear invariant, e.g. u_1+u_2 = 1.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_linmod_inplace","page":"API reference","title":"PositiveIntegrators.prob_pds_linmod_inplace","text":"prob_pds_linmod_inplace\n\nSame as prob_pds_linmod but with in-place computation.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_nonlinmod","page":"API reference","title":"PositiveIntegrators.prob_pds_nonlinmod","text":"prob_pds_nonlinmod\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -fracu_1u_2u_1 + 10\nu_2 = fracu_1u_2u_1 + 10 - 03u_2\nu_3 = 03 u_2\nendaligned\n\nwith initial value mathbfu_0 = (998 001 001)^T and time domain (00 300). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 100.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_npzd","page":"API reference","title":"PositiveIntegrators.prob_pds_npzd","text":"prob_pds_npzd\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = 001u_2 + 001u_3 + 0003u_4 - fracu_1u_2001 + u_1\nu_2 = fracu_1u_2001 + u_1- 001u_2 - 05( 1 - e^-121u_2^2)u_3 - 005u_2\nu_3 = 05(1 - e^-121u_2^2)u_3 - 001u_3 - 002u_3\nu_4 = 005u_2 + 002u_3 - 0003u_4\nendaligned\n\nwith initial value mathbfu_0 = (80 20 10 40)^T and time domain (00 100). There is one independent linear invariant, e.g. u_1+u_2+u_3+u_4 = 150.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"Application of modified Patankar schemes to stiff biogeochemical models for the water column.\" Ocean Dynamics 55 (2005): 326-337. DOI: 10.1007/s10236-005-0001-x\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_robertson","page":"API reference","title":"PositiveIntegrators.prob_pds_robertson","text":"prob_pds_robertson\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -004u_1+10^4 u_2u_3\nu_2 =  004u_1-10^4 u_2u_3-310^7 u_2^2\nu_3 = 310^7 u_2^2\nendaligned\n\nwith initial value mathbfu_0 = (10 00 00)^T and time domain (00 10^11). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 10.\n\nReferences\n\nErnst Hairer, Gerd Wanner. \"Solving Ordinary Differential Equations II - Stiff and Differential-Algebraic Problems.\" 2nd Edition, Springer (2002): Section IV.1.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_sir","page":"API reference","title":"PositiveIntegrators.prob_pds_sir","text":"prob_pds_sir\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -2u_1u_2\nu_2 = 2u_1u_2 - u_2\nu_3 = u_2\nendaligned\n\nwith initial value mathbfu_0 = (099 0005 0005)^T and time domain (00 200). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 10.\n\nReferences\n\nRonald E. Mickens, and Talitha M. Washington. \"NSFD discretizations of interacting population models satisfying conservation laws.\" Computers and Mathematics with Applications 66 (2013): 2307-2316. DOI: 10.1016/j.camwa.2013.06.011\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_stratreac","page":"API reference","title":"PositiveIntegrators.prob_pds_stratreac","text":"prob_pds_stratreac\n\nPositive and nonconservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = r_5 - r_6 -  r_7\nu_2 = 2r_1 - r_2 + r_3 - r_4 + r_6 - r_9 + r_10 - r_11\nu_3 = r_2 - r_3 - r_4 - r_5 - r_7 - r_8\nu_4 = -r_1 -r_2 + r_3 + 2r_4+r_5+2r_7+r_8+r_9\nu_5 = -r_8+r_9+r_10-r_11\nu_6 = r_8-r_9-r_10+r_11\nendaligned\n\nwith reaction rates\n\nbeginaligned\nr_1 =2643 10^-10σ^3 u_4  r_2 =801810^-17u_2 u_4   r_3 =61210^-4σ u_3\nr_4 =156710^-15u_3 u_2   r_5 = 107 10^-3σ^2u_3   r_6 = 71110^-11 81210^6 u_1\nr_7 = 1210^-10u_1 u_3  r_8 = 606210^-15u_3 u_5  r_9 = 106910^-11u_6 u_2\nr_10 = 128910^-2σ u_6  r_11 = 10^-8u_5 u_2\nendaligned\n\nwhere\n\nbeginaligned\nT = t3600 mod 24quad T_r=45quad T_s = 195\nσ(T) = begincases1  T_r T T_s0  textotherwiseendcases\nendaligned\n\nThe initial value is mathbfu_0 = (990610^1 662410^8 532610^11 169710^16 410^6 109310^9)^T and the time domain (432 10^4 302410^5). There are two independent linear invariants, e.g. u_1+u_2+3u_3+2u_4+u_5+2u_6=(113212)cdotmathbfu_0 and u_5+u_6 = 109710^9.\n\nReferences\n\nStephan Nüsslein, Hendrik Ranocha, and David I. Ketcheson. \"Positivity-preserving adaptive Runge-Kutta methods.\" Communications in Applied Mathematics and Computer Science 16 (2021): 155-179. DOI: 10.2140/camcos.2021.16.155\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#Algorithms","page":"API reference","title":"Algorithms","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"MPE\nMPRK22\nSSPMPRK22\nMPRK43I\nMPRK43II\nSSPMPRK43","category":"page"},{"location":"api_reference/#PositiveIntegrators.MPE","page":"API reference","title":"PositiveIntegrators.MPE","text":"MPE([linsolve = ..., small_constant = ...])\n\nThe first-order modified Patankar-Euler algorithm for production-destruction systems. This one-step, one-stage method is first-order accurate, unconditionally positivity-preserving, and linearly implicit.\n\nThe scheme was introduced by Burchard et al. for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension\n\nu_i^n+1 = u_i^n + Δt sum_j ji biggl(p_ij^n fracu_j^n+1u_j^n-d_ij^n fracu_i^n+1u_i^nbiggr) + Deltat p_ii^n - Δt d_ii^nfracu_i^n+1u_i^n,\n\nwhere p_ij^n = p_ij(t^nmathbf u^n) and d_ij^n = d_ij(t^nmathbf u^n).\n\nThe modified Patankar-Euler method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nThe current implementation only supports fixed time steps.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK22","page":"API reference","title":"PositiveIntegrators.MPRK22","text":"MPRK22(α; [linsolve = ..., small_constant = ...])\n\nA family of second-order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step, two-stage method which is second-order accurate, unconditionally positivity-preserving, and linearly implicit. In this implementation the stage-values are conservative as well. The parameter α is described by Kopecz and Meister (2018) and studied by Izgin, Kopecz and Meister (2022) as well as Torlo, Öffner and Ranocha (2022).\n\nThis method supports adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as first order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use a straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\nStefan Kopecz and Andreas Meister. \"On order conditions for modified Patankar-Runge-Kutta schemes.\" Applied Numerical Mathematics 123 (2018): 159-179. DOI: 10.1016/j.apnum.2017.09.004\nThomas Izgin, Stefan Kopecz, and Andreas Meister. \"On Lyapunov stability of positive and conservative time integrators and application to second order modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 56.3 (2022): 1053-1080. DOI: 10.1051/m2an/2022031\nDavide Torlo, Philipp Öffner, and Hendrik Ranocha. \"Issues with positivity-preserving Patankar-type schemes.\" Applied Numerical Mathematics 182 (2022): 117-147. DOI: 10.1016/j.apnum.2022.07.014\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.SSPMPRK22","page":"API reference","title":"PositiveIntegrators.SSPMPRK22","text":"SSPMPRK22(α, β; [linsolve = ..., small_constant = ...])\n\nA family of second-order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step, two-stage method which is second-order accurate, unconditionally positivity-preserving, and linearly implicit. The parameters α and β are described by Huang and Shu (2019) and studied by Huang, Izgin, Kopecz, Meister and Shu (2023). The difference to MPRK22 is that this method is based on the SSP formulation of an explicit second-order Runge-Kutta method. This family of schemes contains the MPRK22 family, where MPRK22(α) = SSMPRK22(0, α) applies.\n\nThis method supports adaptive time stepping, using the first order approximations (σ_i - u_i^n)  τ + u_i^n with τ=1+(α_21β_10^2)(β_20+β_21), see (2.7) in Huang and Shu (2019), to estimate the error.\n\nThe scheme was introduced by Huang and Shu for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nJuntao Huang and Chi-Wang Shu. \"Positivity-Preserving Time Discretizations for Production–Destruction Equations with Applications to Non-equilibrium Flows.\" Journal of Scientific Computing 78 (2019): 1811–1839 DOI: 10.1007/s10915-018-0852-1\nJuntao Huang, Thomas Izgin, Stefan Kopecz, Andreas Meister and Chi-Wang Shu. \"On the stability of strong-stability-preserving modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 57 (2023):1063–1086 DOI: 10.1051/m2an/2023005\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK43I","page":"API reference","title":"PositiveIntegrators.MPRK43I","text":"MPRK43I(α, β; [linsolve = ..., small_constant = ...])\n\nA family of third-order modified Patankar-Runge-Kutta schemes for production-destruction systems, which is based on the two-parameter family of third order explicit Runge–Kutta schemes. Each member of this family is an adaptive, one-step method with four-stages which is third-order accurate, unconditionally positivity-preserving, conservative and linearly implicit. In this implementation the stage-values are conservative as well. The parameters α and β must be chosen such that the Runge–Kutta coefficients are nonnegative, see Kopecz and Meister (2018) for details.\n\nThese methods support adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as second order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThese modified Patankar-Runge-Kutta methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nStefan Kopecz and Andreas Meister. \"Unconditionally positive and conservative third order modified Patankar–Runge–Kutta  discretizations of production–destruction systems.\"  BIT Numerical Mathematics 58 (2018): 691–728. DOI: 10.1007/s10543-018-0705-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK43II","page":"API reference","title":"PositiveIntegrators.MPRK43II","text":"MPRK43II(γ; [linsolve = ..., small_constant = ...])\n\nA family of third-order modified Patankar-Runge-Kutta schemes for production-destruction systems, which is based on the one-parameter family of third order explicit Runge–Kutta schemes with non-negative Runge–Kutta coefficients. Each member of this family is an adaptive, one-step method with four stages which is third-order accurate, unconditionally positivity-preserving, conservative and linearly implicit. In this implementation the stage-values are conservative as well. The parameter γ must satisfy 3/8 ≤ γ ≤ 3/4. Further details are given in Kopecz and Meister (2018).\n\nThis method supports adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as second order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThese modified Patankar-Runge-Kutta methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nStefan Kopecz and Andreas Meister. \"Unconditionally positive and conservative third order modified Patankar–Runge–Kutta  discretizations of production–destruction systems.\"  BIT Numerical Mathematics 58 (2018): 691–728. DOI: 10.1007/s10543-018-0705-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.SSPMPRK43","page":"API reference","title":"PositiveIntegrators.SSPMPRK43","text":"SSPMPRK43([linsolve = ..., small_constant = ...])\n\nA third-order modified Patankar-Runge-Kutta algorithm for production-destruction systems. This scheme is a one-step, four-stage method which is third-order accurate, unconditionally positivity-preserving, and linearly implicit. The scheme is described by Huang, Zhao and Shu (2019) and studied by Huang, Izgin, Kopecz, Meister and Shu (2023). The difference to MPRK43I or MPRK43II is that this method is based on the SSP formulation of an explicit third-order Runge-Kutta method.\n\nThe scheme was introduced by Huang, Zhao and Shu for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nThe current implementation only supports fixed time steps.\n\nReferences\n\nJuntao Huang, Weifeng Zhao and Chi-Wang Shu. \"A Third-Order Unconditionally Positivity-Preserving Scheme for Production–Destruction Equations with Applications to Non-equilibrium Flows.\" Journal of Scientific Computing 79 (2019): 1015–1056 DOI: 10.1007/s10915-018-0881-9\nJuntao Huang, Thomas Izgin, Stefan Kopecz, Andreas Meister and Chi-Wang Shu. \"On the stability of strong-stability-preserving modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 57 (2023):1063–1086 DOI: 10.1051/m2an/2023005\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Auxiliary-functions","page":"API reference","title":"Auxiliary functions","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"isnegative\nisnonnegative","category":"page"},{"location":"api_reference/#PositiveIntegrators.isnegative","page":"API reference","title":"PositiveIntegrators.isnegative","text":"isnegative(sol::ODESolution)\n\nReturns true if sol contains negative elements.\n\nSee also isnonnegative.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.isnonnegative","page":"API reference","title":"PositiveIntegrators.isnonnegative","text":"isnonnegative(u)\n\nNegation of isnegative.    \n\n\n\n\n\n","category":"function"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/SKopecz/PositiveIntegrators.jl/blob/main/LICENSE\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2023-present Stefan Kopecz, Hendrik Ranocha, and contributorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"#PositiveIntegrators.jl","page":"Home","title":"PositiveIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia library PositiveIntegrators.jl provides several time integration methods developed to preserve the positivity of numerical solutions.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PositiveIntegrators.jl is a registered Julia package. Thus, you can install it from the Julia REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"PositiveIntegrators\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to update PositiveIntegrators.jl, you can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update(\"PositiveIntegrators\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"As usual, if you want to update PositiveIntegrators.jl and all other packages in your current project, you can execute","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update()","category":"page"},{"location":"#Basic-examples","page":"Home","title":"Basic examples","text":"","category":"section"},{"location":"#Modified-Patankar-Runge-Kutta-schemes","page":"Home","title":"Modified Patankar-Runge-Kutta schemes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modified Patankar-Runge-Kutta (MPRK) schemes are unconditionally positive and conservative time integration schemes for the solution of positive and conservative ODE systems. The application of these methods is based on the representation of the ODE system as a so-called production-destruction system (PDS).","category":"page"},{"location":"#Production-destruction-systems-(PDS)","page":"Home","title":"Production-destruction systems (PDS)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The application of MPRK schemes requires the ODE system to be represented as a production-destruction system (PDS). A PDS takes the general form","category":"page"},{"location":"","page":"Home","title":"Home","text":"    u_i(t) = sum_j=1^N bigl(p_ij(tboldsymbol u) - d_ij(tboldsymbol u)bigr)quad i=1dotsN","category":"page"},{"location":"","page":"Home","title":"Home","text":"where boldsymbol u=(u_1dotsu_n)^T is the vector of unknowns and both production terms p_ij(tboldsymbol u) and destruction terms d_ij(tboldsymbol u) must be nonnegative for all ij=1dotsN. The meaning behind p_ij and d_ij is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p_ij with ine j represents the sum of all nonnegative terms which appear in equation i with a positive sign and in equation j with a negative sign.\nd_ij with ine j represents the sum of all nonnegative terms which appear in equation i with a negative sign and in equation j with a positive sign.\np_ii represents the sum of all nonnegative terms  which appear in equation i and don't have a negative counterpart in one of the other equations.\nd_ii represents the sum of all negative terms which appear in equation i and don't have a positive counterpart in one of the other equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This naming convention leads to p_ij = d_ji for i j and therefore a PDS is completely defined by the production matrix mathbfP=(p_ij)_ij=1dotsN and the destruction vector mathbfd=(d_ii)_i=1dotsN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As an example we consider the Lotka-Volterra model","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nu_1 = 2u_1-u_1u_2\nu_2 = u_1u_2-u_2\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"which always has positive solutions if positive initial values are supplied. Assuming u_1u_20, the above naming scheme results in","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\np_11(u_1u_2) = 2u_1\np_21(u_1u_2) = u_1u_2 = d_12(u_1u_2) \nd_22(u_1u_2) = u_2\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where all remaining production and destruction terms are zero. Consequently the production matrix mathbf P and destruction vector mathbf d are","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbf P(u_1u_2) = beginpmatrix2u_1  0 u_1u_2  0endpmatrixquad mathbf d(u_1u_2) = beginpmatrix0 u_2endpmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"OrdinaryDiffEq\");  Pkg.add(\"Plots\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To solve this PDS together with initial values u_1(0)=u_2(0)=2 on the time domain (010), we first need to create a PDSProblem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PositiveIntegrators # load PDSProblem\n\nP(u, p, t) = [2*u[1]  0; u[1]*u[2]  0] # Production matrix\nd(u, p, t) = [0; u[2]] # Destruction vector\n\nu0 = [2.0; 2.0] # initial values\ntspan = (0.0, 10.0) # time span\n\n# Create PDS\nprob = PDSProblem(P, d, u0, tspan)\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that the problem has been created, we can solve it with any method of PositiveIntegrators.jl. In the following, we use the method MPRK22(1.0). In addition, we could also use any method provided by OrdinaryDiffEq.jl, but these might possibly generate negative approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sol = solve(prob, MPRK22(1.0))\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we can use Plots.jl to visualize the solution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\n\nplot(sol)","category":"page"},{"location":"#Conservative-production-destruction-systems","page":"Home","title":"Conservative production-destruction systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A PDS with the additional property","category":"page"},{"location":"","page":"Home","title":"Home","text":"  p_ii(tboldsymbol y)=d_ii(tboldsymbol y)=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"for i=1dotsN is called conservative. In this case we have p_ij=d_ji for all ij=1dotsN, which leads to","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracddtsum_i=1^N y_i=sum_i=1^N y_i = sum_mathclapij=1^N bigl(p_ij(tboldsymbol y) - d_ij(tboldsymbol y)bigr)= sum_mathclapij=1^N bigl(p_ij(tboldsymbol y) - p_ji(tboldsymbol y)bigr) = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"This shows that the sum of the state variables of a conservative PDS remains constant over time, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_i=1^N y_i(t) = sum_i=1^N y_i(0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for all times t0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One specific example of a conservative PDS is the SIR model","category":"page"},{"location":"","page":"Home","title":"Home","text":"S = -fracβ S INquad I= fracβ S IN - γ Iquad R=γ I","category":"page"},{"location":"","page":"Home","title":"Home","text":"with N=S+I+R and betagamma0. Assuming SIR0 the production and destruction terms are given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"p_21(SIR) = d_12(SIR) = fracβ S INquad p_32(SIR) = d_23(SIR) = γ I","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the remaining production and destruction terms are zero. The corresponding production matrix mathbf P is","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbf P(SIR) = beginpmatrix0  0  0 fracβ S IN  0  0 0  γ I  0endpmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following example shows how to implement the above SIR model with beta=04 gamma=004, initial conditions S(0)=997 I(0)=3 R(0)=0 and time domain (0 100) using ConservativePDSProblem from PositiveIntegrators.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"OrdinaryDiffEq\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PositiveIntegrators\n\n# Out-of-place implementation of the P matrix for the SIR model\nfunction P(u, p, t)\n  S, I, R = u\n\n  β = 0.4\n  γ = 0.04\n  N = 1000.0\n\n  P = zeros(3,3)\n  P[2,1] = β*S*I/N\n  P[3,2] = γ*I\n  return P\nend\n\nu0 = [997.0; 3.0; 0.0]; # initial values\ntspan = (0.0, 100.0); # time span\n\n# Create SIR problem\nprob = ConservativePDSProblem(P, u0, tspan)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the SIR model is not only conservative but also positive, we can use any scheme from PositiveIntegrators.jl to solve it. Here we use MPRK22(1.0). Please note that any method from OrdinaryDiffEq.jl can be used as well, but might possibly generate negative approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sol = solve(prob, MPRK22(1.0))\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we can use Plots.jl to visualize the solution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\n\nplot(sol, label = [\"S\" \"I\" \"R\"], legend=:right)\nplot!(sol.t, sum.(sol.u), label = \"S+I+R\") # Plot S+I+R over time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We see that there is always a nonnegative number of people in each compartment, while the population S+I+R remains constant over time.","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use PositiveIntegrators.jl for your research, please cite it using the bibtex entry","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{PositiveIntegrators.jl,\n  title={{PositiveIntegrators.jl}: {A} {J}ulia library of positivity-preserving\n         time integration methods},\n  author={Kopecz, Stefan and Ranocha, Hendrik and contributors},\n  year={2023},\n  doi={10.5281/zenodo.10868393},\n  url={https://github.com/SKopecz/PositiveIntegrators.jl}\n}","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"page"}]
}
